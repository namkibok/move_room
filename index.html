<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ì§‘ ê¾¸ë¯¸ê¸° (ëª¨ë°”ì¼ ì´ë™ ìˆ˜ì •)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: white;
            overscroll-behavior: none;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none; 
        }
        #labels-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden;
        }
        .obj-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            transition: opacity 0.2s, transform 0.1s;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
        }
        
        .room-label {
            font-size: 14px;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.8);
            border: 1px solid rgba(255,255,255,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            pointer-events: auto; 
            cursor: move;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .room-label:hover {
            background: rgba(37, 99, 235, 0.9);
            transform: translate(-50%, -105%) scale(1.05);
            z-index: 20;
        }

        .furniture-label {
            pointer-events: auto; 
            cursor: move;
        }
        .furniture-label:hover {
            background: rgba(50, 50, 50, 0.9);
            border-color: #ffeb3b;
            transform: translate(-50%, -105%) scale(1.1);
            z-index: 20;
        }
        
        #ui-toggle-btn {
            position: absolute; top: 15px; left: 15px; z-index: 2000;
            background: rgba(0,0,0,0.8); color: white; border: 1px solid #555;
            padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 20px; display: none;
        }

        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px; border-radius: 12px;
            backdrop-filter: blur(5px);
            width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
            pointer-events: auto;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 1000;
        }
        
        @media (max-width: 768px) {
            #ui-toggle-btn { display: block; }
            #ui-layer {
                top: 70px; left: 50%; transform: translateX(-50%); width: 85%; max-height: 70vh;
            }
            #ui-layer.collapsed {
                transform: translateX(-50%) translateY(-150%); opacity: 0; pointer-events: none;
            }
            .btn { padding: 14px; font-size: 14px; }
            input[type="range"] { height: 20px; }
        }

        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-thumb { background-color: #555; border-radius: 3px; }
        
        h1 {
            font-size: 18px; margin: 0 0 15px 0; color: #eee; border-bottom: 1px solid #444; padding-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        
        .mode-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
        .tab-btn {
            flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer;
            background: #333; color: #aaa; font-weight: bold; transition: all 0.2s;
        }
        .tab-btn.active { background: #3b82f6; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }

        .control-group { display: none; margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px; }
        
        body.mode-layout .group-layout { display: block !important; }
        body.mode-furniture .group-furniture { display: block !important; }
        
        .control-label { font-size: 12px; color:#aaa; margin-bottom: 8px; display: block; font-weight: bold; }
        .size-display { float: right; color: #ffd700; font-weight: normal; }
        
        .btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s; text-align: center; color: white;
        }
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .btn-view { background-color: #555; }
        .btn-add { background-color: #3b82f6; }
        .btn-save { background-color: #10b981; }
        .btn-danger { background-color: #d32f2f; }
        
        .input-row { display: flex; gap: 5px; margin-bottom: 5px; }
        input[type="number"], input[type="text"], select {
            width: 100%; padding: 10px; background: #333; border: 1px solid #555; color: white; border-radius: 4px; box-sizing: border-box; font-size: 14px;
        }
        input[type="range"] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        #selection-panel {
            display: none; background: rgba(60, 60, 60, 0.4); border: 1px solid #555; border-radius: 8px; padding: 10px; margin-top: 10px;
        }
        .instruction { margin-top: 10px; font-size: 11px; color: #888; line-height: 1.4; user-select: text; }
        
        #active-room-indicator {
            font-size: 12px; color: #4fc3f7; margin-bottom: 10px; font-weight: bold;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body class="mode-layout">

    <div id="labels-container"></div>
    <button id="ui-toggle-btn" onclick="toggleUI()">â˜° ë©”ë‰´</button>

    <div id="ui-layer">
        <h1>ğŸ¡ ì§‘ ê¾¸ë¯¸ê¸°
            <span style="font-size:12px; cursor:pointer; display:none;" onclick="toggleUI()">âœ•</span>
        </h1>

        <div class="mode-tabs">
            <button class="tab-btn active" id="tab-layout" onclick="setMode('layout')">ğŸ—ï¸ ë°© í¸ì§‘</button>
            <button class="tab-btn" id="tab-furniture" onclick="setMode('furniture')">ğŸª‘ ê°€êµ¬ ë°°ì¹˜</button>
        </div>
        
        <div style="margin-bottom: 15px;">
            <button class="btn btn-view" id="toggleViewBtn" onclick="toggleView()">ë·° ì „í™˜ (3D â†” 2D)</button>
            <button class="btn btn-save" onclick="saveSceneAsImage()">ğŸ“· ë„ë©´ ì €ì¥</button>
        </div>

        <!-- êµ¬ì¡° í¸ì§‘ UI -->
        <div class="control-group group-layout">
            <span class="control-label">ì‹ ê·œ ë°© ì¶”ê°€</span>
            <div class="input-row">
                <input type="text" id="newRoomName" placeholder="ë°© ì´ë¦„ (ì˜ˆ: ì•ˆë°©)">
                <button class="btn btn-add" style="width: 80px; margin:0;" onclick="handleAddRoom()">ì¶”ê°€</button>
            </div>
            <div class="instruction" style="margin-bottom: 15px;">
                * ë°© <strong>ì´ë¦„í‘œ(ë¼ë²¨)</strong>ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ì„¸ìš”.
            </div>
            
            <div id="room-edit-panel" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
                <span class="control-label" style="color:#4fc3f7">ì„ íƒëœ ë°© ì„¤ì •</span>
                <span class="control-label">ë°© ì´ë¦„</span>
                <input type="text" id="editRoomName" placeholder="ë°© ì´ë¦„ ë³€ê²½" onchange="updateSelectedRoomName()" style="margin-bottom: 8px;">
                <span class="control-label">í¬ê¸° ì¡°ì ˆ (cm)</span>
                <div class="input-row">
                    <input type="number" id="editRoomW" placeholder="ê°€ë¡œ" onchange="updateSelectedRoomSize()">
                    <input type="number" id="editRoomH" placeholder="ì„¸ë¡œ" onchange="updateSelectedRoomSize()">
                </div>
                <button class="btn btn-danger" onclick="deleteSelectedRoom()">ë°© ì‚­ì œ</button>
            </div>
        </div>

        <!-- ê°€êµ¬ ë°°ì¹˜ UI -->
        <div class="control-group group-furniture">
            <div id="active-room-indicator">ì„ íƒëœ ë°©: ì—†ìŒ (ë°© ì´ë¦„ì„ í´ë¦­í•˜ì„¸ìš”)</div>

            <span class="control-label">ê°€êµ¬ ì¶”ê°€</span>
            <input type="text" id="newFurnitureName" placeholder="ì´ë¦„ (ì˜ˆ: ë‚´ ì±…ìƒ)" style="margin-bottom: 8px;">
            <div class="input-row">
                <select id="newFurnitureType">
                    <option value="bed">ì¹¨ëŒ€</option>
                    <option value="desk">ì±…ìƒ</option>
                    <option value="vanity">í™”ì¥ëŒ€</option>
                    <option value="table">ì‹íƒ</option>
                    <option value="kitchen">ì£¼ë°© (ì‹±í¬ëŒ€)</option>
                    <option value="fridge">ëƒ‰ì¥ê³ </option>
                    <option value="washer">ì„¸íƒê¸°</option>
                    <option value="ac_stand">ì—ì–´ì»¨ (ìŠ¤íƒ ë“œ)</option>
                    <option value="tv_wall">TV (ë²½ê±¸ì´)</option>
                    <option value="wardrobe">ì˜·ì¥</option>
                    <option value="lamp">ì¡°ëª… (ìŠ¤íƒ ë“œ)</option>
                    <option value="door">ë¬¸ (Door)</option>
                    <option value="window">ì°½ë¬¸</option>
                    <option value="box">ê¸°ë³¸ ë°•ìŠ¤</option>
                </select>
                <button class="btn btn-add" style="width: 60px; margin:0;" onclick="handleAddCustom()">ì¶”ê°€</button>
            </div>
            <button class="btn btn-danger" style="margin-top: 10px;" onclick="clearAllFurniture()">ëª¨ë“  ê°€êµ¬ ì‚­ì œ</button>
        </div>

        <!-- ê°€êµ¬ ì„ íƒ íŒ¨ë„ -->
        <div id="selection-panel" class="control-group" style="display:none;">
            <span class="control-label" style="color: #4fc3f7;">ì„ íƒë¨: <span id="selected-name">-</span></span>
            <span class="control-label" style="margin-top:5px;">
                íšŒì „ <span id="displayRotation" class="size-display">0Â°</span>
            </span>
            <input type="range" id="rotation" min="0" max="360" step="5" value="0" oninput="rotateSelected()">
            <span class="control-label" style="margin-top:5px;">
                ê°€ë¡œ (W) <span id="displayW" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleX" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">
            <span class="control-label">
                ê¹Šì´ (D) <span id="displayD" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleZ" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">
            <button class="btn btn-danger" onclick="deleteSelected()">ê°€êµ¬ ì‚­ì œ ğŸ—‘ï¸</button>
        </div>

        <div class="instruction">
            <strong>ì¡°ì‘ ë°©ë²•:</strong><br>
            â€¢ ğŸ–±ï¸ <strong>ë¼ë²¨/ê°€êµ¬ í´ë¦­ ë“œë˜ê·¸: ì´ë™</strong><br>
            â€¢ ğŸ–±ï¸ í´ë¦­ ìœ ì§€ ì‹œ: 3D íšŒì „ ë©ˆì¶¤<br>
            â€¢ ğŸ–±ï¸ í´ë¦­ í•´ì œ ì‹œ: ì´ë™ ë©ˆì¶¤ & íšŒì „ ê°€ëŠ¥<br>
            â€¢ ğŸ–±ï¸ ìš°í´ë¦­ ë“œë˜ê·¸: í™”ë©´ ì´ë™ (Pan)
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let isDragging = false;
        let selectedObject = null;
        let activeRoom = null; 
        let offset = new THREE.Vector3();
        let is2D = false; 
        let appMode = 'layout'; 

        let rooms = []; 
        let furnitures = []; 
        let roomCounter = 0;

        const UNIT_TO_CM = 10; 
        const WALL_HEIGHT = 24; 
        const ROOM_GAP = 5; 

        let dragPlane;

        function toggleUI() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('ui-toggle-btn');
            ui.classList.toggle('collapsed');
            btn.innerHTML = ui.classList.contains('collapsed') ? 'â˜° ë©”ë‰´' : 'âœ• ë‹«ê¸°';
        }

        function setMode(mode) {
            appMode = mode;
            document.body.className = 'mode-' + mode;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('tab-' + mode).classList.add('active');
            
            deselectObject(); 
            
            if (mode === 'layout') {
                document.getElementById('selection-panel').style.display = 'none';
            } else {
                document.getElementById('room-edit-panel').style.display = 'none';
                updateActiveRoomDisplay();
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 50, 500);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(60, 80, 80); 
            camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            dragPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(10000, 10000),
                new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide })
            );
            dragPlane.rotation.x = -Math.PI / 2;
            scene.add(dragPlane);

            const grid = new THREE.GridHelper(300, 60, 0xcccccc, 0xeeeeee);
            grid.position.y = -0.1;
            scene.add(grid);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);
            
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            window.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('touchend', onMouseUp, false);

            window.addEventListener('pointermove', onMouseMove, false);
            window.addEventListener('pointerup', onMouseUp, false);

            addNewRoom(40, 40, "ë‚´ ë°©");
            animate();
        }

        function handleAddRoom() {
            const nameInput = document.getElementById('newRoomName');
            let name = nameInput.value.trim();
            if (!name) name = `ë°© ${roomCounter + 1}`;
            addNewRoom(40, 40, name);
            nameInput.value = '';
        }

        function addNewRoom(w = 40, h = 40, roomName = "ë°©") {
            const roomId = `room_${++roomCounter}`;
            const roomGroup = new THREE.Group();
            roomGroup.userData = { isRoom: true, id: roomId, w: w, h: h, name: roomName };

            const floorGeo = new THREE.BoxGeometry(w, 1, h);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xE5CFAA });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            floor.userData = { isFloor: true, parentRoomId: roomId };
            roomGroup.add(floor);

            updateRoomWalls(roomGroup, w, h);

            let posX = 0;
            if (rooms.length > 0) {
                let rightmostRoom = rooms[rooms.length - 1]; 
                let edgeX = rightmostRoom.mesh.position.x + (rightmostRoom.mesh.userData.w / 2);
                posX = edgeX + ROOM_GAP + (w / 2);
            }
            roomGroup.position.set(posX, 0, 0);

            scene.add(roomGroup);
            rooms.push({ mesh: roomGroup, id: roomId });

            createRoomLabel(roomGroup, roomName);
            
            activeRoom = roomGroup;
            if(appMode === 'layout') selectObject(floor);
            updateActiveRoomDisplay();
        }

        function createRoomLabel(roomGroup, name) {
            const div = document.createElement('div');
            div.className = 'obj-label room-label';
            div.textContent = name;
            div.addEventListener('pointerdown', (e) => {
                if(e.button !== 0) return;
                e.preventDefault(); 
                e.stopPropagation(); 
                const floor = roomGroup.children.find(c => c.userData.isFloor);
                if (floor) {
                    startDragFromLabel(e, floor);
                }
            });
            document.getElementById('labels-container').appendChild(div);
            roomGroup.userData.labelEl = div;
        }

        function updateRoomWalls(roomGroup, w, h) {
            for(let i = roomGroup.children.length - 1; i >= 0; i--) {
                if(roomGroup.children[i].userData.isWall) roomGroup.remove(roomGroup.children[i]);
            }
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const thick = 1;
            const height = WALL_HEIGHT;
            const back = new THREE.Mesh(new THREE.BoxGeometry(w + thick*2, height, thick), wallMat);
            back.position.set(0, height/2, -h/2 - thick/2);
            back.userData = { isWall: true };
            roomGroup.add(back);
            const left = new THREE.Mesh(new THREE.BoxGeometry(thick, height, h), wallMat);
            left.position.set(-w/2 - thick/2, height/2, 0);
            left.userData = { isWall: true };
            roomGroup.add(left);
        }

        function updateSelectedRoomSize() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            const w_cm = parseFloat(document.getElementById('editRoomW').value);
            const h_cm = parseFloat(document.getElementById('editRoomH').value);
            if (w_cm > 0 && h_cm > 0) {
                const w = w_cm / UNIT_TO_CM;
                const h = h_cm / UNIT_TO_CM;
                group.userData.w = w;
                group.userData.h = h;
                selectedObject.geometry.dispose();
                selectedObject.geometry = new THREE.BoxGeometry(w, 1, h);
                updateRoomWalls(group, w, h);
            }
        }

        function updateSelectedRoomName() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            const newName = document.getElementById('editRoomName').value.trim();
            if(newName) {
                group.userData.name = newName;
                if(group.userData.labelEl) group.userData.labelEl.textContent = newName;
                updateActiveRoomDisplay();
            }
        }

        function deleteSelectedRoom() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            if(activeRoom === group) activeRoom = null; 
            scene.remove(group);
            if(group.userData.labelEl) group.userData.labelEl.remove();
            rooms = rooms.filter(r => r.mesh !== group);
            deselectObject();
        }

        function handleAddCustom() {
            const nameInput = document.getElementById('newFurnitureName');
            const typeSelect = document.getElementById('newFurnitureType');
            let name = nameInput.value.trim();
            const type = typeSelect.value;
            if (!name) name = typeSelect.options[typeSelect.selectedIndex].text;
            addFurniture(type, name);
            nameInput.value = '';
        }

        function addFurniture(type, name) {
            let geometry, material, mesh;
            let startY = 0;
            let baseSize = { w:10, h:10, d:10 };

            if (type === 'bed') {
                baseSize = { w:14, h:4, d:20 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h/2;
                const mat = new THREE.Mesh(
                    new THREE.BoxGeometry(13.5, 2, 19.5), 
                    new THREE.MeshStandardMaterial({color:0xAACCFF}) 
                );
                mat.position.y = 2; mesh.add(mat);
            } else if (type === 'desk') {
                baseSize = { w:12, h:7, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xA0522D });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(1,7,1);
                const lM = new THREE.MeshStandardMaterial({color:0x333});
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ const l = new THREE.Mesh(lG,lM); l.position.set(x*(baseSize.w/2-1), -3.5, z*(baseSize.d/2-1)); mesh.add(l); }));
            } else if (type === 'vanity') {
                baseSize = { w:10, h:7, d:5 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xFFB6C1 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(0.8, 7, 0.8);
                const lM = new THREE.MeshStandardMaterial({ color: 0x888888 });
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ const l = new THREE.Mesh(lG,lM); l.position.set(x*(baseSize.w/2-1), -3.5, z*(baseSize.d/2-1)); mesh.add(l); }));
                const mirrorFrame = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 0.5), new THREE.MeshStandardMaterial({ color: 0xFFB6C1 }));
                mirrorFrame.position.set(0, 3.25, -baseSize.d/2 + 0.5);
                mesh.add(mirrorFrame);
                const mirrorGlass = new THREE.Mesh(new THREE.PlaneGeometry(7, 5), new THREE.MeshStandardMaterial({ color: 0xADD8E6, metalness: 0.8, roughness: 0.1 }));
                mirrorGlass.position.z = 0.3;
                mirrorFrame.add(mirrorGlass);
            } else if (type === 'table') {
                baseSize = { w:14, h:7, d:8 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(1.2, 7, 1.2);
                const lM = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ const l = new THREE.Mesh(lG,lM); l.position.set(x*(baseSize.w/2-1.5), -3.5, z*(baseSize.d/2-1.5)); mesh.add(l); }));
            } else if (type === 'kitchen') {
                baseSize = { w:18, h:9, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x9E9E9E });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
                const top = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w + 0.5, 0.5, baseSize.d + 0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                top.position.y = baseSize.h / 2 + 0.25;
                mesh.add(top);
                const sink = new THREE.Mesh(new THREE.BoxGeometry(6, 0.6, 4), new THREE.MeshStandardMaterial({ color: 0x8899aa }));
                sink.position.set(-4, baseSize.h / 2 + 0.3, 0);
                mesh.add(sink);
                const tapV = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                tapV.position.set(-4, baseSize.h / 2 + 1.5, -2);
                mesh.add(tapV);
                const tapH = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                tapH.rotation.x = Math.PI / 2;
                tapH.position.set(-4, baseSize.h / 2 + 2.5, -1.25);
                mesh.add(tapH);
            } else if (type === 'fridge') {
                baseSize = { w:9, h:18, d:8 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, metalness: 0.3, roughness: 0.2 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
                const line = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w+0.1, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                line.position.set(0, 2, baseSize.d/2);
                mesh.add(line);
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                handle.position.set(-3, 3, baseSize.d/2 + 0.2);
                mesh.add(handle);
            } else if (type === 'washer') {
                baseSize = { w:6, h:8.5, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
                const doorGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.5, 32);
                const doorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.1 });
                const door = new THREE.Mesh(doorGeo, doorMat);
                door.rotation.x = Math.PI / 2;
                door.position.set(0, 1, baseSize.d/2);
                mesh.add(door);
                const panel = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                panel.position.set(0, baseSize.h/2 - 1, baseSize.d/2);
                mesh.add(panel);
            } else if (type === 'ac_stand') {
                baseSize = { w:3.5, h:18, d:3.5 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
                const vent = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w-0.2, 4, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                vent.position.set(0, 5, baseSize.d/2);
                mesh.add(vent);
                const vent2 = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w-0.2, 4, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                vent2.position.set(0, -1, baseSize.d/2);
                mesh.add(vent2);
            } else if (type === 'tv_wall') {
                baseSize = { w:12, h:7, d:0.5 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.6, roughness:0.2 });
                mesh = new THREE.Mesh(geometry, material);
                startY = 15;
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(baseSize.w-0.5, baseSize.h-0.5), new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x111111 }));
                screen.position.z = baseSize.d/2 + 0.01;
                mesh.add(screen);
            } else if (type === 'wardrobe') {
                baseSize = { w:8, h:18, d:6 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(8,18,6), new THREE.MeshStandardMaterial({color:0x555}));
                startY = 9;
            } else if (type === 'lamp') {
                baseSize = { w:3, h:10, d:3 };
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.5,8), new THREE.MeshStandardMaterial({color:0x222}));
                startY = 4;
                const shade = new THREE.Mesh(new THREE.ConeGeometry(2,2,16,1,true), new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:0.5, side:2}));
                shade.position.y=3; mesh.add(shade);
                const light = new THREE.PointLight(0xffaa00, 1, 30);
                light.position.y=2; mesh.add(light);
            } else if (type === 'door') {
                baseSize = { w:9, h:21, d:0.5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(9,21,0.5), new THREE.MeshStandardMaterial({color:0x8b4513}));
                startY = 10.5;
                const k = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color:0xffd700}));
                k.position.set(3.5,0,0.4); mesh.add(k);
            } else if (type === 'window') {
                baseSize = { w:12, h:12, d:0.5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(12,12,0.5), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0}));
                startY = 15;
                const fM = new THREE.MeshStandardMaterial({color:0x5d4037});
                const glassM = new THREE.MeshPhysicalMaterial({color:0x88ccff, transparent:true, opacity:0.4, metalness:0.1, roughness:0});
                const frame = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(13,0.5,1), fM); top.position.y=6; frame.add(top);
                const bot = new THREE.Mesh(new THREE.BoxGeometry(13,0.5,1), fM); bot.position.y=-6; frame.add(bot);
                const l = new THREE.Mesh(new THREE.BoxGeometry(0.5,12,1), fM); l.position.x=-6; frame.add(l);
                const r = new THREE.Mesh(new THREE.BoxGeometry(0.5,12,1), fM); r.position.x=6; frame.add(r);
                const glass = new THREE.Mesh(new THREE.BoxGeometry(11.5,11.5,0.2), glassM); frame.add(glass);
                const cross = new THREE.Mesh(new THREE.BoxGeometry(12,0.3,0.4), fM); frame.add(cross);
                const v = new THREE.Mesh(new THREE.BoxGeometry(0.3,12,0.4), fM); frame.add(v);
                mesh.add(frame);
            } else { 
                baseSize = { w:5, h:5, d:5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(5,5,5), new THREE.MeshStandardMaterial({color:0xccc}));
                startY = 2.5;
            }

            if(mesh) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.position.y = startY;
                mesh.userData = { 
                    isFurniture: true, 
                    type: type, 
                    label: name,
                    baseW: baseSize.w, 
                    baseD: baseSize.d,
                    originalColor: material && material.color ? material.color.getHex() : 0xffffff
                };
                
                if (activeRoom) {
                    mesh.position.set(0, startY, 0); 
                    activeRoom.add(mesh);
                } else {
                    mesh.position.set(0, startY, 0);
                    scene.add(mesh);
                }

                furnitures.push(mesh);
                createLabel(mesh);
                
                selectObject(mesh);
            }
        }

        function createLabel(mesh) {
            const div = document.createElement('div');
            div.className = 'obj-label furniture-label';
            document.getElementById('labels-container').appendChild(div);
            mesh.userData.labelEl = div;
            
            div.addEventListener('pointerdown', (e) => {
                if(e.button !== 0) return;
                e.preventDefault(); 
                e.stopPropagation(); 
                startDragFromLabel(e, mesh);
            });

            updateLabel(mesh);
        }

        function startDragFromLabel(e, targetObj) {
            selectObject(targetObj);
            isDragging = true;
            controls.enabled = false; 
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const planeIntersects = raycaster.intersectObject(dragPlane);
            if (planeIntersects.length > 0) {
                let targetPos = targetObj.userData.isFurniture ? targetObj.position : targetObj.parent.position;
                offset.copy(planeIntersects[0].point).sub(targetPos);
            }
        }

        function updateLabel(mesh) {
            if(!mesh.userData.labelEl) return;
            const w = Math.round(mesh.userData.baseW * mesh.scale.x * UNIT_TO_CM);
            const d = Math.round(mesh.userData.baseD * mesh.scale.z * UNIT_TO_CM);
            mesh.userData.labelEl.innerHTML = `<div style="color:#ffeb3b; font-weight:bold">${mesh.userData.label}</div><div>${w}x${d} cm</div>`;
            
            if(mesh === selectedObject && appMode === 'furniture') {
                document.getElementById('displayW').textContent = w + ' cm';
                document.getElementById('displayD').textContent = d + ' cm';
            }
        }

        function updateLabelsPos() {
            furnitures.forEach(f => {
                if(!f.userData.labelEl) return;
                const pos = new THREE.Vector3();
                f.getWorldPosition(pos);
                pos.y += 10; 
                pos.project(camera);
                updateElementPos(f.userData.labelEl, pos);
            });
            rooms.forEach(r => {
                if(!r.mesh.userData.labelEl) return;
                const pos = r.mesh.position.clone();
                pos.y = 1; 
                pos.project(camera);
                updateElementPos(r.mesh.userData.labelEl, pos);
            });
        }

        function updateElementPos(el, pos) {
            if(pos.z > 1) { el.style.display='none'; return; }
            const x = (pos.x * .5 + .5) * window.innerWidth;
            const y = (pos.y * -.5 + .5) * window.innerHeight;
            el.style.display='block';
            el.style.left = x+'px'; el.style.top = y+'px';
        }

        function clearAllFurniture() {
            furnitures.forEach(f => {
                f.parent.remove(f); 
                if(f.userData.labelEl) f.userData.labelEl.remove();
            });
            furnitures = [];
            if(selectedObject && selectedObject.userData.isFurniture) deselectObject();
        }

        function onMouseDown(event) {
            // [ìˆ˜ì •] ëª¨ë°”ì¼ í„°ì¹˜ ëŒ€ì‘ (button ì²´í¬ íŒ¨ìŠ¤)
            if (event.type !== 'touchstart' && event.button !== 0) return;
            
            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);

            let candidates = [...furnitures];
            const floors = rooms.map(r => r.mesh.children.find(c => c.userData.isFloor)).filter(f=>f);
            candidates = candidates.concat(floors);

            const intersects = raycaster.intersectObjects(candidates, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                
                let selected = null;
                let curr = target;
                while (curr) {
                    if (curr.userData.isFurniture || curr.userData.isFloor) {
                        selected = curr;
                        break;
                    }
                    if (curr.parent === scene) break;
                    curr = curr.parent;
                }

                if (selected) {
                    let canSelect = false;
                    if (appMode === 'layout') {
                        if (selected.userData.isFloor) canSelect = true;
                    } else {
                        if (selected.userData.isFurniture || selected.userData.isFloor) canSelect = true;
                    }

                    if (canSelect) {
                        selectObject(selected);
                        
                        if(appMode === 'furniture' && selected.userData.isFloor) {
                            isDragging = false;
                        } else {
                            isDragging = true;
                            controls.enabled = false; 
                        }

                        const planeIntersects = raycaster.intersectObject(dragPlane);
                        if (planeIntersects.length > 0 && isDragging) {
                            const worldPos = new THREE.Vector3();
                            selected.getWorldPosition(worldPos);
                            offset.copy(planeIntersects[0].point).sub(worldPos);
                        }
                    }
                }
            } else {
                if(!isDragging) deselectObject();
            }
        }

        function onMouseMove(event) {
            updateMouse(event);
            
            raycaster.setFromCamera(mouse, camera);
            let hoverCandidates = [...furnitures, ...rooms.map(r => r.mesh.children.find(c => c.userData.isFloor)).filter(f=>f)];
            const intersects = raycaster.intersectObjects(hoverCandidates, true);
            document.body.style.cursor = intersects.length > 0 || isDragging ? 'pointer' : 'default';

            if (isDragging && selectedObject) {
                const planeIntersects = raycaster.intersectObject(dragPlane);
                if (planeIntersects.length > 0) {
                    const point = planeIntersects[0].point;
                    const targetWorldPos = point.sub(offset);

                    if (selectedObject.userData.isFloor) {
                        selectedObject.parent.position.set(targetWorldPos.x, 0, targetWorldPos.z);
                    } else if (selectedObject.userData.isFurniture) {
                        if (selectedObject.parent && selectedObject.parent.userData.isRoom) {
                            selectedObject.parent.worldToLocal(targetWorldPos);
                        }
                        
                        const room = selectedObject.parent;
                        if(room && room.userData.isRoom) {
                            const roomW = room.userData.w;
                            const roomH = room.userData.h;
                            
                            const angle = selectedObject.rotation.y;
                            const w = selectedObject.userData.baseW * selectedObject.scale.x;
                            const d = selectedObject.userData.baseD * selectedObject.scale.z;
                            
                            const boundW = Math.abs(Math.cos(angle)*w) + Math.abs(Math.sin(angle)*d);
                            const boundD = Math.abs(Math.sin(angle)*w) + Math.abs(Math.cos(angle)*d);
                            
                            const limitX = Math.max(0, (roomW - boundW) / 2);
                            const limitZ = Math.max(0, (roomH - boundD) / 2);
                            
                            targetWorldPos.x = Math.max(-limitX, Math.min(limitX, targetWorldPos.x));
                            targetWorldPos.z = Math.max(-limitZ, Math.min(limitZ, targetWorldPos.z));
                        }

                        selectedObject.position.set(targetWorldPos.x, selectedObject.position.y, targetWorldPos.z);
                    }
                }
            }
        }

        function onMouseUp() {
            if(isDragging) {
                isDragging = false;
                controls.enabled = true;
                // [ìˆ˜ì •] 2D ëª¨ë“œì¼ ë•Œë§Œ íšŒì „ ì ê¸ˆ ìœ ì§€, 3DëŠ” íšŒì „ ê°€ëŠ¥
                if(!is2D) {
                    controls.enableRotate = true;
                } else {
                    controls.enableRotate = false;
                }
            }
        }

        function selectObject(obj) {
            if(selectedObject && selectedObject !== obj) deselectObject();
            selectedObject = obj;

            if (obj.material && obj.material.emissive) {
                obj.userData.currentEmissive = obj.material.emissive.getHex();
                obj.material.emissive.setHex(0x555555);
            }
            
            if (obj.userData.isFloor) {
                activeRoom = obj.parent; 
                obj.material.emissive.setHex(0x444444); 
                updateActiveRoomDisplay();
                
                if (appMode === 'layout') {
                    const p = document.getElementById('room-edit-panel');
                    p.style.display = 'block';
                    document.getElementById('editRoomName').value = obj.parent.userData.name;
                    document.getElementById('editRoomW').value = obj.parent.userData.w * UNIT_TO_CM;
                    document.getElementById('editRoomH').value = obj.parent.userData.h * UNIT_TO_CM;
                }
                document.getElementById('selection-panel').style.display = 'none';
            }
            else if (obj.userData.isFurniture) {
                controls.enableRotate = false; 

                const p = document.getElementById('selection-panel');
                p.style.display = 'block';
                document.getElementById('selected-name').textContent = obj.userData.label;
                document.getElementById('scaleX').value = obj.scale.x;
                document.getElementById('scaleZ').value = obj.scale.z;
                let deg = Math.round(obj.rotation.y * 180 / Math.PI);
                if(deg < 0) deg += 360;
                document.getElementById('rotation').value = deg % 360;
                document.getElementById('displayRotation').textContent = (deg % 360) + 'Â°';

                updateLabel(obj);
                updateActiveRoomDisplay();
                
                document.getElementById('room-edit-panel').style.display = 'none';
            }
        }

        function deselectObject() {
            if(!selectedObject) return;

            // [ìˆ˜ì •] íšŒì „ ë³µêµ¬ (2D ì²´í¬)
            if(!is2D) controls.enableRotate = true;

            if (selectedObject.userData.isFloor) {
                selectedObject.material.emissive.setHex(0x000000); // emissive ë„ê¸°
                document.getElementById('room-edit-panel').style.display = 'none';
            }
            else if (selectedObject.userData.isFurniture) {
                 if(selectedObject.material && selectedObject.material.emissive) {
                     selectedObject.material.emissive.setHex(selectedObject.userData.currentEmissive || 0);
                 }
                 document.getElementById('selection-panel').style.display = 'none';
            }
            selectedObject = null;
            updateActiveRoomDisplay();
        }
        
        function updateActiveRoomDisplay() {
            const el = document.getElementById('active-room-indicator');
            let text = "";
            
            if (activeRoom) {
                text = `ì„ íƒëœ ë°©: <span style="color:#fff">${activeRoom.userData.name}</span> (ì—¬ê¸°ì— ê°€êµ¬ê°€ ì¶”ê°€ë©ë‹ˆë‹¤)`;
            } else {
                text = "ì„ íƒëœ ë°©: ì—†ìŒ (ë°© ì´ë¦„ì„ í´ë¦­í•˜ì„¸ìš”)";
            }

            if (selectedObject && selectedObject.userData.isFurniture) {
                text += ` / <span style="color:#ffeb3b">${selectedObject.userData.label}</span>`;
            }
            
            el.innerHTML = text;
        }

        function updateMouse(e) {
            let cx = e.clientX;
            let cy = e.clientY;
            if(e.changedTouches && e.changedTouches.length > 0) {
                cx = e.changedTouches[0].clientX;
                cy = e.changedTouches[0].clientY;
            }
            mouse.x = (cx / window.innerWidth) * 2 - 1;
            mouse.y = -(cy / window.innerHeight) * 2 + 1;
        }

        function resizeSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const sx = parseFloat(document.getElementById('scaleX').value);
                const sz = parseFloat(document.getElementById('scaleZ').value);
                selectedObject.scale.set(sx, 1, sz);
                updateLabel(selectedObject);
            }
        }

        function rotateSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const deg = parseFloat(document.getElementById('rotation').value);
                selectedObject.rotation.y = deg * Math.PI / 180;
                document.getElementById('displayRotation').textContent = deg + 'Â°';
            }
        }
        
        function deleteSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const obj = selectedObject;
                obj.parent.remove(obj); 
                furnitures = furnitures.filter(f => f !== obj);
                if(obj.userData.labelEl) obj.userData.labelEl.remove();
                deselectObject();
            }
        }

        function toggleView() {
            is2D = !is2D;
            const btn = document.getElementById('toggleViewBtn');
            if(is2D) {
                btn.textContent = "3D ë·°ë¡œ ì „í™˜";
                controls.enableRotate = false;
                controls.reset();
                camera.position.set(0, 200, 0);
                camera.lookAt(0,0,0);
            } else {
                btn.textContent = "ë·° ì „í™˜ (3D â†” 2D)";
                controls.enableRotate = true;
                camera.position.set(60, 80, 80);
                camera.lookAt(0,0,0);
            }
        }

        function saveSceneAsImage() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `home_design.png`;
            link.href = renderer.domElement.toDataURL("image/png");
            link.click();
        }

        function onTouchStart(e) { e.preventDefault(); onMouseDown(e); }
        function onTouchMove(e) { e.preventDefault(); onMouseMove(e); }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateLabelsPos();
        }

        init();
    </script>
</body>
</html>
