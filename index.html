<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ì§‘ ê¾¸ë¯¸ê¸° (í™”ë©´ ì €ì¥ ìˆ˜ì •)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: white;
            overscroll-behavior: none;
            user-select: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            touch-action: none; 
        }
        #labels-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; overflow: hidden;
        }
        .obj-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            transition: opacity 0.2s, transform 0.1s;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
        }
        
        .room-label {
            font-size: 14px;
            font-weight: bold;
            background: rgba(59, 130, 246, 0.8);
            border: 1px solid rgba(255,255,255,0.8);
            padding: 6px 12px;
            border-radius: 20px;
            pointer-events: auto; 
            cursor: move;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        .room-label:hover {
            background: rgba(37, 99, 235, 0.9);
            transform: translate(-50%, -105%) scale(1.05);
            z-index: 20;
        }

        .furniture-label {
            pointer-events: auto; 
            cursor: move;
        }
        .furniture-label:hover {
            background: rgba(50, 50, 50, 0.9);
            border-color: #ffeb3b;
            transform: translate(-50%, -105%) scale(1.1);
            z-index: 20;
        }
        
        #ui-toggle-btn {
            position: absolute; top: 15px; left: 15px; z-index: 2000;
            background: rgba(0,0,0,0.8); color: white; border: 1px solid #555;
            padding: 10px 15px; border-radius: 8px; cursor: pointer; font-size: 20px; display: none;
        }

        #ui-layer {
            position: absolute; top: 20px; left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px; border-radius: 12px;
            backdrop-filter: blur(5px);
            width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
            pointer-events: auto;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 1000;
            
            touch-action: pan-y; 
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }
        
        @media (max-width: 768px) {
            #ui-toggle-btn { display: block; }
            #ui-layer {
                top: 70px; left: 50%; transform: translateX(-50%); width: 85%; max-height: 70vh;
            }
            #ui-layer.collapsed {
                transform: translateX(-50%) translateY(-150%); opacity: 0; pointer-events: none;
            }
            .btn { padding: 14px; font-size: 14px; }
            input[type="range"] { height: 20px; }
        }

        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-thumb { background-color: #555; border-radius: 3px; }
        
        h1 {
            font-size: 18px; margin: 0 0 15px 0; color: #eee; border-bottom: 1px solid #444; padding-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        
        .mode-tabs { display: flex; gap: 5px; margin-bottom: 15px; }
        .tab-btn {
            flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer;
            background: #333; color: #aaa; font-weight: bold; transition: all 0.2s;
        }
        .tab-btn.active { background: #3b82f6; color: white; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }

        .control-group { display: none; margin-bottom: 20px; border-bottom: 1px solid #444; padding-bottom: 15px; }
        
        body.mode-layout .group-layout { display: block !important; }
        body.mode-furniture .group-furniture { display: block !important; }
        
        .control-label { font-size: 12px; color:#aaa; margin-bottom: 8px; display: block; font-weight: bold; }
        .size-display { float: right; color: #ffd700; font-weight: normal; }
        
        .btn {
            display: block; width: 100%; padding: 10px; margin-bottom: 8px; border: none; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 13px; transition: all 0.2s; text-align: center; color: white;
        }
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .btn-view { background-color: #555; }
        .btn-add { background-color: #3b82f6; }
        .btn-save { background-color: #10b981; }
        .btn-danger { background-color: #d32f2f; }
        .btn-data { background-color: #7c4dff; }
        
        .input-row { display: flex; gap: 5px; margin-bottom: 5px; }
        input[type="number"], input[type="text"], select {
            width: 100%; padding: 10px; background: #333; border: 1px solid #555; color: white; border-radius: 4px; box-sizing: border-box; font-size: 14px;
        }
        input[type="range"] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        /* ì»¬ëŸ¬ í”¼ì»¤ ìŠ¤íƒ€ì¼ */
        input[type="color"] {
            width: 100%;
            height: 40px;
            padding: 2px;
            background: #333;
            border: 1px solid #555;
            cursor: pointer;
        }

        #selection-panel {
            display: none; background: rgba(60, 60, 60, 0.4); border: 1px solid #555; border-radius: 8px; padding: 10px; margin-top: 10px;
        }
        .instruction { margin-top: 10px; font-size: 11px; color: #888; line-height: 1.4; user-select: text; }
        
        #active-room-indicator {
            font-size: 12px; color: #4fc3f7; margin-bottom: 10px; font-weight: bold;
        }
        
        #file-input { display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body class="mode-layout">

    <div id="labels-container"></div>
    <button id="ui-toggle-btn" onclick="toggleUI()">â˜° ë©”ë‰´</button>

    <input type="file" id="file-input" accept=".json" onchange="loadData(this)">

    <div id="ui-layer">
        <h1>ğŸ¡ ì§‘ ê¾¸ë¯¸ê¸°
            <span style="font-size:12px; cursor:pointer; display:none;" onclick="toggleUI()">âœ•</span>
        </h1>

        <div class="mode-tabs">
            <button class="tab-btn active" id="tab-layout" onclick="setMode('layout')">ğŸ—ï¸ ë°© í¸ì§‘</button>
            <button class="tab-btn" id="tab-furniture" onclick="setMode('furniture')">ğŸª‘ ê°€êµ¬ ë°°ì¹˜</button>
        </div>
        
        <div style="margin-bottom: 15px;">
            <button class="btn btn-view" id="toggleViewBtn" onclick="toggleView()">ë·° ì „í™˜ (3D â†” 2D)</button>
            <button class="btn btn-save" onclick="saveSceneAsImage()">ğŸ“· í™”ë©´ ì €ì¥</button>
            <div style="display:flex; gap:5px;">
                <button class="btn btn-data" onclick="saveData()">ğŸ’¾ ì €ì¥ (JSON)</button>
                <button class="btn btn-data" onclick="document.getElementById('file-input').click()">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</button>
            </div>
        </div>

        <!-- êµ¬ì¡° í¸ì§‘ UI -->
        <div class="control-group group-layout">
            <span class="control-label">ì‹ ê·œ ë°© ì¶”ê°€</span>
            <div class="input-row">
                <input type="text" id="newRoomName" placeholder="ë°© ì´ë¦„ (ì˜ˆ: ì•ˆë°©)">
                <button class="btn btn-add" style="width: 80px; margin:0;" onclick="handleAddRoom()">ì¶”ê°€</button>
            </div>
            <div class="instruction" style="margin-bottom: 15px;">
                * ë°© <strong>ì´ë¦„í‘œ(ë¼ë²¨)</strong>ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ìœ„ì¹˜ë¥¼ ì˜®ê¸°ì„¸ìš”.
            </div>
            
            <div id="room-edit-panel" style="display:none; margin-top:10px; border-top:1px solid #555; padding-top:10px;">
                <span class="control-label" style="color:#4fc3f7">ì„ íƒëœ ë°© ì„¤ì •</span>
                <span class="control-label">ë°© ì´ë¦„</span>
                <input type="text" id="editRoomName" placeholder="ë°© ì´ë¦„ ë³€ê²½" onchange="updateSelectedRoomName()" style="margin-bottom: 8px;">
                
                <span class="control-label">ìƒ‰ìƒ ë³€ê²½</span>
                <div class="input-row">
                    <div style="flex:1">
                        <span style="font-size:10px; color:#aaa;">ë°”ë‹¥</span>
                        <input type="color" id="editRoomFloorColor" onchange="updateRoomFloorColor()" oninput="updateRoomFloorColor()">
                    </div>
                    <div style="flex:1">
                        <span style="font-size:10px; color:#aaa;">ë²½</span>
                        <input type="color" id="editRoomWallColor" onchange="updateRoomWallColor()" oninput="updateRoomWallColor()">
                    </div>
                </div>

                <span class="control-label" style="margin-top:10px;">í¬ê¸° ì¡°ì ˆ (cm)</span>
                <div class="input-row">
                    <input type="number" id="editRoomW" placeholder="ê°€ë¡œ" onchange="updateSelectedRoomSize()">
                    <input type="number" id="editRoomH" placeholder="ì„¸ë¡œ" onchange="updateSelectedRoomSize()">
                </div>
                <button class="btn btn-danger" onclick="deleteSelectedRoom()">ë°© ì‚­ì œ</button>
            </div>
        </div>

        <!-- ê°€êµ¬ ë°°ì¹˜ UI -->
        <div class="control-group group-furniture">
            <div id="active-room-indicator">ì„ íƒëœ ë°©: ì—†ìŒ (ë°© ì´ë¦„ì„ í´ë¦­í•˜ì„¸ìš”)</div>

            <span class="control-label">ê°€êµ¬ ì¶”ê°€</span>
            <input type="text" id="newFurnitureName" placeholder="ì´ë¦„ (ì˜ˆ: ë‚´ ì±…ìƒ)" style="margin-bottom: 8px;">
            <div class="input-row">
                <select id="newFurnitureType">
                    <optgroup label="ê°€êµ¬">
                        <option value="bed">ì¹¨ëŒ€</option>
                        <option value="sofa">ì‡¼íŒŒ</option>
                        <option value="massage_chair">ì•ˆë§ˆê¸°</option>
                        <option value="desk">ì±…ìƒ</option>
                        <option value="wardrobe">ì˜·ì¥</option>
                        <option value="vanity">í™”ì¥ëŒ€</option>
                        <option value="table">ì‹íƒ</option>
                        <option value="pantry">íŒ¬íŠ¸ë¦¬ ì„ ë°˜</option>
                        <option value="cattower">ìº£íƒ€ì›Œ</option>
                        <option value="doghouse">ê°•ì•„ì§€ì§‘</option>
                        <option value="box">ê¸°ë³¸ ë°•ìŠ¤</option>
                    </optgroup>
                    <optgroup label="ê°€ì „ì œí’ˆ">
                        <option value="kitchen">ì£¼ë°© (ì‹±í¬ëŒ€)</option>
                        <option value="fridge">ëƒ‰ì¥ê³ </option>
                        <option value="washer">ì„¸íƒê¸°</option>
                        <option value="ac_stand">ì—ì–´ì»¨ (ìŠ¤íƒ ë“œ)</option>
                        <option value="tv_wall">TV (ë²½ê±¸ì´)</option>
                    </optgroup>
                    <optgroup label="ì¸í…Œë¦¬ì–´/ê¸°íƒ€">
                        <option value="plant">í™”ë¶„</option>
                        <option value="aquarium">ìˆ˜ì¡±ê´€</option>
                        <option value="curtain">ì»¤íŠ¼</option>
                        <option value="lamp">ì¡°ëª… (ìŠ¤íƒ ë“œ)</option>
                        <option value="door">ë¬¸ (Door)</option>
                        <option value="window">ì°½ë¬¸</option>
                    </optgroup>
                </select>
                <button class="btn btn-add" style="width: 60px; margin:0;" onclick="handleAddCustom()">ì¶”ê°€</button>
            </div>
        </div>

        <!-- ê°€êµ¬ ì„ íƒ íŒ¨ë„ -->
        <div id="selection-panel" class="control-group" style="display:none;">
            <span class="control-label" style="color: #4fc3f7;">ì„ íƒë¨: <span id="selected-name">-</span></span>
            
            <span class="control-label" style="margin-top:5px;">ê°€êµ¬ ìƒ‰ìƒ</span>
            <input type="color" id="editFurnitureColor" onchange="updateFurnitureColor()" oninput="updateFurnitureColor()">

            <span class="control-label" style="margin-top:5px;">
                íšŒì „ <span id="displayRotation" class="size-display">0Â°</span>
            </span>
            <input type="range" id="rotation" min="0" max="360" step="5" value="0" oninput="rotateSelected()">
            <span class="control-label" style="margin-top:5px;">
                ê°€ë¡œ (W) <span id="displayW" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleX" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">
            <span class="control-label">
                ê¹Šì´ (D) <span id="displayD" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleZ" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">
            <button class="btn btn-danger" onclick="deleteSelected()">ê°€êµ¬ ì‚­ì œ ğŸ—‘ï¸</button>
        </div>

        <div class="instruction">
            <strong>ì¡°ì‘ ë°©ë²•:</strong><br>
            â€¢ ğŸ–±ï¸ <strong>ë¼ë²¨/ê°€êµ¬ í´ë¦­ ë“œë˜ê·¸: ì´ë™</strong><br>
            â€¢ ğŸ–±ï¸ í´ë¦­ ìœ ì§€ ì‹œ: 3D íšŒì „ ë©ˆì¶¤<br>
            â€¢ ğŸ–±ï¸ í´ë¦­ í•´ì œ ì‹œ: ì´ë™ ë©ˆì¶¤ & íšŒì „ ê°€ëŠ¥<br>
            â€¢ ğŸ–±ï¸ ìš°í´ë¦­ ë“œë˜ê·¸: í™”ë©´ ì´ë™ (Pan)
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let isDragging = false;
        let selectedObject = null;
        let activeRoom = null; 
        let offset = new THREE.Vector3();
        let is2D = false; 
        let appMode = 'layout'; 

        let rooms = []; 
        let furnitures = []; 
        let roomCounter = 0;

        const UNIT_TO_CM = 10; 
        const WALL_HEIGHT = 24; 
        const ROOM_GAP = 5; 

        let dragPlane;

        function toggleUI() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('ui-toggle-btn');
            ui.classList.toggle('collapsed');
            btn.innerHTML = ui.classList.contains('collapsed') ? 'â˜° ë©”ë‰´' : 'âœ• ë‹«ê¸°';
        }

        function setMode(mode) {
            appMode = mode;
            document.body.className = 'mode-' + mode;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('tab-' + mode).classList.add('active');
            
            deselectObject(); 
            
            if (mode === 'layout') {
                document.getElementById('selection-panel').style.display = 'none';
            } else {
                document.getElementById('room-edit-panel').style.display = 'none';
                updateActiveRoomDisplay();
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 50, 500);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(60, 80, 80); 
            camera.lookAt(0,0,0);

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            dragPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(10000, 10000),
                new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0, depthWrite: false, side: THREE.DoubleSide })
            );
            dragPlane.rotation.x = -Math.PI / 2;
            scene.add(dragPlane);

            const grid = new THREE.GridHelper(300, 60, 0xcccccc, 0xeeeeee);
            grid.position.y = -0.1;
            scene.add(grid);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('mouseup', onMouseUp, false);
            
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            window.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('touchend', onMouseUp, false);

            window.addEventListener('pointermove', onMouseMove, false);
            window.addEventListener('pointerup', onMouseUp, false);

            addNewRoom(40, 40, "ë‚´ ë°©");

            const uiPanel = document.getElementById('ui-layer');
            uiPanel.addEventListener('touchstart', function(e) {
                controls.enabled = false;
                e.stopPropagation(); 
            }, { passive: false });

            uiPanel.addEventListener('touchmove', function(e) {
                e.stopPropagation();
            }, { passive: false });

            uiPanel.addEventListener('touchend', function(e) {
                setTimeout(() => {
                    if (!isDragging) {
                        controls.enabled = true;
                        if(is2D) controls.enableRotate = false;
                    }
                }, 100);
            }, { passive: false });

            uiPanel.addEventListener('mouseenter', () => { controls.enabled = false; });
            uiPanel.addEventListener('mouseleave', () => { 
                if(!isDragging) {
                    controls.enabled = true; 
                    if(is2D) controls.enableRotate = false;
                }
            });
            uiPanel.addEventListener('wheel', (e) => { e.stopPropagation(); });
            uiPanel.addEventListener('mousedown', (e) => { e.stopPropagation(); });

            animate();
        }

        // --- í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---
        function onTouchStart(e) {
            if(e.target.closest('#ui-layer') || e.target.closest('#ui-toggle-btn')) return;
            e.preventDefault(); 
            onMouseDown(e); 
        }

        function onTouchMove(e) {
            if(e.target.closest('#ui-layer')) return;
            e.preventDefault();
            onMouseMove(e);
        }

        // --- ë°ì´í„° ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸° ---
        function saveData() {
            try {
                const roomsData = rooms.map(r => {
                    const floor = r.mesh.children.find(c => c.userData.isFloor);
                    const wall = r.mesh.children.find(c => c.userData.isWall);
                    return {
                        id: r.id,
                        name: r.mesh.userData.name,
                        w: r.mesh.userData.w,
                        h: r.mesh.userData.h,
                        posX: r.mesh.position.x,
                        posZ: r.mesh.position.z,
                        floorColor: floor ? floor.material.color.getHex() : 0xE5CFAA,
                        wallColor: wall ? wall.material.color.getHex() : 0xffffff
                    };
                });

                const furnituresData = furnitures.map(f => {
                    const parentRoom = (f.parent && f.parent.userData.isRoom) ? f.parent.userData.id : null;
                    let color = f.userData.originalColor;
                    let tinted = false;
                    f.traverse(child => { 
                        if(child.isMesh && child.userData.canTint) {
                            color = child.material.color.getHex();
                            tinted = true;
                        }
                    });
                    if(!tinted && f.material && f.material.color) color = f.material.color.getHex();

                    return {
                        type: f.userData.type,
                        label: f.userData.label,
                        posX: f.position.x,
                        posY: f.position.y,
                        posZ: f.position.z,
                        rotY: f.rotation.y,
                        scaleX: f.scale.x,
                        scaleZ: f.scale.z,
                        color: color,
                        parentRoomId: parentRoom
                    };
                });

                const data = {
                    rooms: roomsData,
                    furnitures: furnituresData
                };

                const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `home_data_${new Date().getTime()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!");

            } catch (err) {
                console.error("ì €ì¥ ì‹¤íŒ¨:", err);
                alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
            }
        }

        function loadData(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    clearAll();
                    
                    const roomMap = {};
                    if(data.rooms) {
                        data.rooms.forEach(rd => {
                            const newRoomMesh = restoreRoom(rd);
                            roomMap[rd.id] = newRoomMesh;
                        });
                    }

                    if(data.furnitures) {
                        data.furnitures.forEach(fd => {
                            restoreFurniture(fd, roomMap);
                        });
                    }

                    if(rooms.length > 0) {
                        activeRoom = rooms[0].mesh;
                        updateActiveRoomDisplay();
                    }
                    
                    updateLabelsPos(); 

                    controls.enabled = true;
                    if(!is2D) controls.enableRotate = true;
                    
                    deselectObject(); 
                    
                    alert("ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!");

                } catch (err) {
                    console.error("íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜:", err);
                    alert("íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                }
            };
            reader.readAsText(file);
            input.value = ''; 
        }

        function clearAll() {
            [...furnitures].forEach(f => {
                f.parent.remove(f);
                if(f.userData.labelEl) f.userData.labelEl.remove();
            });
            furnitures = [];

            [...rooms].forEach(r => {
                scene.remove(r.mesh);
                if(r.mesh.userData.labelEl) r.mesh.userData.labelEl.remove();
            });
            rooms = [];
            roomCounter = 0;
            
            selectedObject = null;
            activeRoom = null;
            deselectObject();
        }

        function restoreRoom(rd) {
            const roomGroup = new THREE.Group();
            roomGroup.userData = { isRoom: true, id: rd.id, w: rd.w, h: rd.h, name: rd.name };

            const floorGeo = new THREE.BoxGeometry(rd.w, 1, rd.h);
            const floorMat = new THREE.MeshStandardMaterial({ color: rd.floorColor });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            floor.userData = { isFloor: true, parentRoomId: rd.id };
            roomGroup.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ color: rd.wallColor });
            const thick = 1;
            const height = WALL_HEIGHT;
            const back = new THREE.Mesh(new THREE.BoxGeometry(rd.w + thick*2, height, thick), wallMat);
            back.position.set(0, height/2, -rd.h/2 - thick/2);
            back.userData = { isWall: true };
            roomGroup.add(back);
            const left = new THREE.Mesh(new THREE.BoxGeometry(thick, height, rd.h), wallMat.clone()); 
            left.position.set(-rd.w/2 - thick/2, height/2, 0);
            left.userData = { isWall: true };
            roomGroup.add(left);

            roomGroup.position.set(rd.posX, 0, rd.posZ);
            scene.add(roomGroup);
            rooms.push({ mesh: roomGroup, id: rd.id });
            createRoomLabel(roomGroup, rd.name);
            
            const idNum = parseInt(rd.id.replace('room_', ''));
            if(!isNaN(idNum) && idNum > roomCounter) roomCounter = idNum;

            return roomGroup;
        }

        function restoreFurniture(fd, roomMap) {
            addFurniture(fd.type, fd.label);
            const newMesh = furnitures[furnitures.length - 1]; 
            
            newMesh.position.set(fd.posX, fd.posY, fd.posZ);
            newMesh.rotation.y = fd.rotY;
            newMesh.scale.set(fd.scaleX, 1, fd.scaleZ);

            newMesh.userData.originalColor = fd.color;
            let tinted = false;
            newMesh.traverse(child => {
                if(child.isMesh && child.userData.canTint) {
                    child.material.color.setHex(fd.color);
                    tinted = true;
                }
            });
            if(!tinted && newMesh.isMesh && newMesh.material.color) newMesh.material.color.setHex(fd.color);

            if (fd.parentRoomId && roomMap[fd.parentRoomId]) {
                newMesh.parent.remove(newMesh); 
                roomMap[fd.parentRoomId].add(newMesh);
            }
            
            updateLabel(newMesh);
        }

        // --- ë°©(Room) ê´€ë¦¬ ---
        function handleAddRoom() {
            const nameInput = document.getElementById('newRoomName');
            let name = nameInput.value.trim();
            if (!name) name = `ë°© ${roomCounter + 1}`;
            addNewRoom(40, 40, name);
            nameInput.value = '';
        }

        function addNewRoom(w = 40, h = 40, roomName = "ë°©") {
            const roomId = `room_${++roomCounter}`;
            const roomGroup = new THREE.Group();
            roomGroup.userData = { isRoom: true, id: roomId, w: w, h: h, name: roomName };

            const floorGeo = new THREE.BoxGeometry(w, 1, h);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0xE5CFAA });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.y = -0.5;
            floor.receiveShadow = true;
            floor.userData = { isFloor: true, parentRoomId: roomId };
            roomGroup.add(floor);

            updateRoomWalls(roomGroup, w, h);

            let posX = 0;
            if (rooms.length > 0) {
                let rightmostRoom = rooms[rooms.length - 1]; 
                let edgeX = rightmostRoom.mesh.position.x + (rightmostRoom.mesh.userData.w / 2);
                posX = edgeX + ROOM_GAP + (w / 2);
            }
            roomGroup.position.set(posX, 0, 0);

            scene.add(roomGroup);
            rooms.push({ mesh: roomGroup, id: roomId });

            createRoomLabel(roomGroup, roomName);
            
            activeRoom = roomGroup;
            if(appMode === 'layout') selectObject(floor);
            updateActiveRoomDisplay();
        }

        function createRoomLabel(roomGroup, name) {
            const div = document.createElement('div');
            div.className = 'obj-label room-label';
            div.textContent = name;
            div.addEventListener('pointerdown', (e) => {
                if(e.button !== 0) return;
                e.preventDefault(); 
                e.stopPropagation(); 
                const floor = roomGroup.children.find(c => c.userData.isFloor);
                if (floor) {
                    startDragFromLabel(e, floor);
                }
            });
            document.getElementById('labels-container').appendChild(div);
            roomGroup.userData.labelEl = div;
        }

        function updateRoomWalls(roomGroup, w, h) {
            let oldColor = 0xffffff;
            const oldWall = roomGroup.children.find(c => c.userData.isWall);
            if(oldWall) oldColor = oldWall.material.color.getHex();

            for(let i = roomGroup.children.length - 1; i >= 0; i--) {
                if(roomGroup.children[i].userData.isWall) roomGroup.remove(roomGroup.children[i]);
            }
            const wallMat = new THREE.MeshStandardMaterial({ color: oldColor });
            const thick = 1;
            const height = WALL_HEIGHT;
            const back = new THREE.Mesh(new THREE.BoxGeometry(w + thick*2, height, thick), wallMat);
            back.position.set(0, height/2, -h/2 - thick/2);
            back.userData = { isWall: true };
            roomGroup.add(back);
            const left = new THREE.Mesh(new THREE.BoxGeometry(thick, height, h), wallMat);
            left.position.set(-w/2 - thick/2, height/2, 0);
            left.userData = { isWall: true };
            roomGroup.add(left);
        }

        function updateRoomFloorColor() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const colorVal = document.getElementById('editRoomFloorColor').value;
            selectedObject.material.color.set(colorVal);
        }

        function updateRoomWallColor() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const roomGroup = selectedObject.parent;
            const colorVal = document.getElementById('editRoomWallColor').value;
            roomGroup.children.forEach(child => {
                if(child.userData.isWall) {
                    child.material.color.set(colorVal);
                }
            });
        }

        function updateFurnitureColor() {
            if (!selectedObject || !selectedObject.userData.isFurniture) return;
            const colorVal = document.getElementById('editFurnitureColor').value;
            
            let tinted = false;
            selectedObject.traverse((child) => {
                if (child.isMesh && child.userData.canTint) {
                    child.material.color.set(colorVal);
                    tinted = true;
                }
            });
            
            if (!tinted) {
                if(selectedObject.isMesh) {
                    selectedObject.material.color.set(colorVal);
                } else {
                    const firstMesh = selectedObject.children.find(c => c.isMesh);
                    if(firstMesh) firstMesh.material.color.set(colorVal);
                }
            }
        }

        function updateSelectedRoomSize() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            const w_cm = parseFloat(document.getElementById('editRoomW').value);
            const h_cm = parseFloat(document.getElementById('editRoomH').value);
            if (w_cm > 0 && h_cm > 0) {
                const w = w_cm / UNIT_TO_CM;
                const h = h_cm / UNIT_TO_CM;
                group.userData.w = w;
                group.userData.h = h;
                selectedObject.geometry.dispose();
                selectedObject.geometry = new THREE.BoxGeometry(w, 1, h);
                updateRoomWalls(group, w, h);
            }
        }

        function updateSelectedRoomName() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            const newName = document.getElementById('editRoomName').value.trim();
            if(newName) {
                group.userData.name = newName;
                if(group.userData.labelEl) group.userData.labelEl.textContent = newName;
                updateActiveRoomDisplay();
            }
        }

        function deleteSelectedRoom() {
            if (!selectedObject || !selectedObject.userData.isFloor) return;
            const group = selectedObject.parent;
            if(activeRoom === group) activeRoom = null; 
            scene.remove(group);
            if(group.userData.labelEl) group.userData.labelEl.remove();
            rooms = rooms.filter(r => r.mesh !== group);
            deselectObject();
        }

        function handleAddCustom() {
            const nameInput = document.getElementById('newFurnitureName');
            const typeSelect = document.getElementById('newFurnitureType');
            let name = nameInput.value.trim();
            const type = typeSelect.value;
            if (!name) name = typeSelect.options[typeSelect.selectedIndex].text;
            addFurniture(type, name);
            nameInput.value = '';
        }

        function addFurniture(type, name) {
            let geometry, material, mesh;
            let startY = 0;
            let baseSize = { w:10, h:10, d:10 };

            if (type === 'bed') {
                baseSize = { w:14, h:4, d:20 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true; 
                startY = baseSize.h/2;
                const mat = new THREE.Mesh(
                    new THREE.BoxGeometry(13.5, 2, 19.5), 
                    new THREE.MeshStandardMaterial({color:0xAACCFF}) 
                );
                mat.position.y = 2; mesh.add(mat);
            } else if (type === 'sofa') {
                baseSize = { w:16, h:6, d:7 };
                mesh = new THREE.Group();
                mesh.userData.canTint = true; 
                startY = 3; 
                const fabricMat = new THREE.MeshStandardMaterial({ color: 0x708090 }); 
                const seat = new THREE.Mesh(new THREE.BoxGeometry(16, 3, 7), fabricMat);
                seat.userData.canTint = true;
                mesh.add(seat);
                const back = new THREE.Mesh(new THREE.BoxGeometry(16, 6, 2), fabricMat);
                back.position.set(0, 4.5, -2.5);
                back.userData.canTint = true;
                mesh.add(back);
                const armL = new THREE.Mesh(new THREE.BoxGeometry(2, 5, 7), fabricMat);
                armL.position.set(-7, 2, 0);
                armL.userData.canTint = true;
                mesh.add(armL);
                const armR = new THREE.Mesh(new THREE.BoxGeometry(2, 5, 7), fabricMat);
                armR.position.set(7, 2, 0);
                armR.userData.canTint = true;
                mesh.add(armR);
            } else if (type === 'massage_chair') {
                baseSize = { w:8, h:12, d:10 };
                mesh = new THREE.Group();
                mesh.userData.canTint = true;
                startY = 6;
                const leatherMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4 }); 
                const seat = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 6), leatherMat);
                seat.position.y = -4; seat.userData.canTint = true;
                mesh.add(seat);
                const back = new THREE.Mesh(new THREE.BoxGeometry(6, 12, 3), leatherMat);
                back.position.set(0, 2, -3); back.rotation.x = -0.2; 
                back.userData.canTint = true;
                mesh.add(back);
                const leg = new THREE.Mesh(new THREE.BoxGeometry(6, 4, 4), leatherMat);
                leg.position.set(0, -5, 4); leg.rotation.x = -0.3;
                leg.userData.canTint = true;
                mesh.add(leg);
                const armL = new THREE.Mesh(new THREE.BoxGeometry(1, 6, 8), leatherMat);
                armL.position.set(-3.5, -2, 0); armL.userData.canTint = true;
                mesh.add(armL);
                const armR = new THREE.Mesh(new THREE.BoxGeometry(1, 6, 8), leatherMat);
                armR.position.set(3.5, -2, 0); armR.userData.canTint = true;
                mesh.add(armR);
                const head = new THREE.Mesh(new THREE.BoxGeometry(4, 2, 2), new THREE.MeshStandardMaterial({color:0x550000}));
                head.position.set(0, 7, -3.5);
                mesh.add(head);
            } else if (type === 'desk') {
                baseSize = { w:12, h:7, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xA0522D });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(1,7,1);
                const lM = new THREE.MeshStandardMaterial({color:0x333});
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ 
                    const l = new THREE.Mesh(lG,lM); 
                    l.position.set(x*(baseSize.w/2-1), -3.5, z*(baseSize.d/2-1)); 
                    l.userData.canTint = true; 
                    mesh.add(l); 
                }));
            } else if (type === 'vanity') {
                baseSize = { w:10, h:7, d:5 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xFFB6C1 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(0.8, 7, 0.8);
                const lM = new THREE.MeshStandardMaterial({ color: 0x888888 });
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ const l = new THREE.Mesh(lG,lM); l.position.set(x*(baseSize.w/2-1), -3.5, z*(baseSize.d/2-1)); mesh.add(l); }));
                const mirrorFrame = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 0.5), new THREE.MeshStandardMaterial({ color: 0xFFB6C1 }));
                mirrorFrame.position.set(0, 3.25, -baseSize.d/2 + 0.5);
                mirrorFrame.userData.canTint = true;
                mesh.add(mirrorFrame);
                const mirrorGlass = new THREE.Mesh(new THREE.PlaneGeometry(7, 5), new THREE.MeshStandardMaterial({ color: 0xADD8E6, metalness: 0.8, roughness: 0.1 }));
                mirrorGlass.position.z = 0.3;
                mirrorFrame.add(mirrorGlass);
            } else if (type === 'table') {
                baseSize = { w:14, h:7, d:8 };
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xDEB887 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h;
                const lG = new THREE.BoxGeometry(1.2, 7, 1.2);
                const lM = new THREE.MeshStandardMaterial({ color: 0xD2B48C });
                [-1,1].forEach(x=>[-1,1].forEach(z=>{ 
                    const l = new THREE.Mesh(lG,lM); 
                    l.position.set(x*(baseSize.w/2-1.5), -3.5, z*(baseSize.d/2-1.5)); 
                    l.userData.canTint = true;
                    mesh.add(l); 
                }));
            } else if (type === 'kitchen') {
                baseSize = { w:18, h:9, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x9E9E9E });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h / 2;
                const top = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w + 0.5, 0.5, baseSize.d + 0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                top.position.y = baseSize.h / 2 + 0.25;
                mesh.add(top);
                const sink = new THREE.Mesh(new THREE.BoxGeometry(6, 0.6, 4), new THREE.MeshStandardMaterial({ color: 0x8899aa }));
                sink.position.set(-4, baseSize.h / 2 + 0.3, 0);
                mesh.add(sink);
                const tapV = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                tapV.position.set(-4, baseSize.h / 2 + 1.5, -2);
                mesh.add(tapV);
                const tapH = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                tapH.rotation.x = Math.PI / 2;
                tapH.position.set(-4, baseSize.h / 2 + 2.5, -1.25);
                mesh.add(tapH);
            } else if (type === 'fridge') {
                baseSize = { w:9, h:18, d:8 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xE0E0E0, metalness: 0.3, roughness: 0.2 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h / 2;
                const line = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w+0.1, 0.2, 0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                line.position.set(0, 2, baseSize.d/2);
                mesh.add(line);
                const handle = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 0.5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                handle.position.set(-3, 3, baseSize.d/2 + 0.2);
                mesh.add(handle);
            } else if (type === 'washer') {
                baseSize = { w:6, h:8.5, d:6 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xF5F5F5 });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h / 2;
                const doorGeo = new THREE.CylinderGeometry(2.2, 2.2, 0.5, 32);
                const doorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.5, roughness: 0.1 });
                const door = new THREE.Mesh(doorGeo, doorMat);
                door.rotation.x = Math.PI / 2;
                door.position.set(0, 1, baseSize.d/2);
                mesh.add(door);
                const panel = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
                panel.position.set(0, baseSize.h/2 - 1, baseSize.d/2);
                mesh.add(panel);
            } else if (type === 'ac_stand') {
                baseSize = { w:3.5, h:18, d:3.5 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                mesh = new THREE.Mesh(geometry, material);
                mesh.userData.canTint = true;
                startY = baseSize.h / 2;
                const vent = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w-0.2, 4, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                vent.position.set(0, 5, baseSize.d/2);
                mesh.add(vent);
                const vent2 = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w-0.2, 4, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                vent2.position.set(0, -1, baseSize.d/2);
                mesh.add(vent2);
            } else if (type === 'tv_wall') {
                baseSize = { w:12, h:7, d:0.5 };
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.6, roughness:0.2 });
                mesh = new THREE.Mesh(geometry, material);
                // TV ëª¸ì²´ëŠ” ìƒ‰ìƒ ë³€ê²½ ì•ˆí•¨
                startY = 15;
                const screen = new THREE.Mesh(new THREE.PlaneGeometry(baseSize.w-0.5, baseSize.h-0.5), new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x111111 }));
                screen.position.z = baseSize.d/2 + 0.01;
                mesh.add(screen);
            } else if (type === 'wardrobe') {
                baseSize = { w:8, h:18, d:6 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(8,18,6), new THREE.MeshStandardMaterial({color:0x555}));
                mesh.userData.canTint = true;
                startY = 9;
            } else if (type === 'lamp') {
                baseSize = { w:3, h:10, d:3 };
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.5,8), new THREE.MeshStandardMaterial({color:0x222}));
                mesh.userData.canTint = true; 
                startY = 4;
                const shade = new THREE.Mesh(new THREE.ConeGeometry(2,2,16,1,true), new THREE.MeshStandardMaterial({color:0xffd700, emissive:0xffd700, emissiveIntensity:0.5, side:2}));
                shade.position.y=3; mesh.add(shade);
                const light = new THREE.PointLight(0xffaa00, 1, 30);
                light.position.y=2; mesh.add(light);
            } else if (type === 'door') {
                baseSize = { w:9, h:21, d:0.5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(9,21,0.5), new THREE.MeshStandardMaterial({color:0x8b4513}));
                mesh.userData.canTint = true;
                startY = 10.5;
                const k = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color:0xffd700}));
                k.position.set(3.5,0,0.4); mesh.add(k);
            } else if (type === 'window') {
                baseSize = { w:12, h:12, d:0.5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(12,12,0.5), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0}));
                startY = 15;
                const fM = new THREE.MeshStandardMaterial({color:0x5d4037});
                const glassM = new THREE.MeshPhysicalMaterial({color:0x88ccff, transparent:true, opacity:0.4, metalness:0.1, roughness:0});
                const frame = new THREE.Group();
                const top = new THREE.Mesh(new THREE.BoxGeometry(13,0.5,1), fM); top.position.y=6; frame.add(top);
                const bot = new THREE.Mesh(new THREE.BoxGeometry(13,0.5,1), fM); bot.position.y=-6; frame.add(bot);
                top.userData.canTint = true;
                bot.userData.canTint = true;
                mesh.add(frame);
                const l = new THREE.Mesh(new THREE.BoxGeometry(0.5,12,1), fM); l.position.x=-6; frame.add(l);
                const r = new THREE.Mesh(new THREE.BoxGeometry(0.5,12,1), fM); r.position.x=6; frame.add(r);
                const glass = new THREE.Mesh(new THREE.BoxGeometry(11.5,11.5,0.2), glassM); frame.add(glass);
                l.userData.canTint = true; r.userData.canTint = true;
            } else if (type === 'aquarium') {
                baseSize = { w:8, h:6, d:4 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(8,6,4), new THREE.MeshBasicMaterial({visible:false}));
                startY = 3; 
                const stand = new THREE.Mesh(new THREE.BoxGeometry(8,2,4), new THREE.MeshStandardMaterial({color:0x333333}));
                stand.position.y = -2;
                stand.userData.canTint = true;
                mesh.add(stand);
                const sand = new THREE.Mesh(new THREE.BoxGeometry(7.6, 0.3, 3.6), new THREE.MeshStandardMaterial({color:0xE1C699}));
                sand.position.y = -0.8;
                mesh.add(sand);
                const plantGeo = new THREE.ConeGeometry(0.15, 1.2, 8);
                const plantMat = new THREE.MeshStandardMaterial({color:0x228B22});
                for(let i=0; i<6; i++) {
                    const plant = new THREE.Mesh(plantGeo, plantMat);
                    plant.position.set((Math.random() - 0.5) * 6, -0.2, (Math.random() - 0.5) * 2.5);
                    plant.rotation.z = (Math.random() - 0.5) * 0.3; 
                    plant.scale.set(1, 0.8 + Math.random()*0.5, 1); 
                    mesh.add(plant);
                }
                const fishGeo = new THREE.ConeGeometry(0.15, 0.5, 8);
                const fishTailGeo = new THREE.ConeGeometry(0.1, 0.2, 8);
                const fishMat = new THREE.MeshStandardMaterial({color:0xFF8C00});
                for(let j=0; j<4; j++) {
                    const fish = new THREE.Group();
                    const body = new THREE.Mesh(fishGeo, fishMat);
                    body.rotation.z = -Math.PI / 2;
                    const tail = new THREE.Mesh(fishTailGeo, fishMat);
                    tail.rotation.z = Math.PI / 2;
                    tail.position.x = -0.35;
                    fish.add(body);
                    fish.add(tail);
                    fish.position.set((Math.random() - 0.5) * 5, 0.5 + (Math.random() * 1.5), (Math.random() - 0.5) * 2);
                    fish.rotation.y = Math.random() * Math.PI * 2; 
                    mesh.add(fish);
                }
                const water = new THREE.Mesh(new THREE.BoxGeometry(7.6, 3.5, 3.6), new THREE.MeshPhongMaterial({color:0x00FFFF, transparent:true, opacity:0.3, shininess: 90}));
                water.position.y = 0.8;
                mesh.add(water);
                const glassMat = new THREE.MeshPhysicalMaterial({color: 0xffffff, metalness: 0, roughness: 0, transparent: true, opacity: 0.15, side: THREE.DoubleSide});
                const glassBox = new THREE.Mesh(new THREE.BoxGeometry(7.8, 3.8, 3.8), glassMat);
                glassBox.position.y = 0.9;
                mesh.add(glassBox);
                const lid = new THREE.Mesh(new THREE.BoxGeometry(8, 0.2, 4), new THREE.MeshStandardMaterial({color:0x222222}));
                lid.position.y = 2.9;
                mesh.add(lid);
            } else if (type === 'curtain') {
                baseSize = { w:14, h:20, d:1 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(14,20,1), new THREE.MeshBasicMaterial({visible:false}));
                startY = 12; 
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,16), new THREE.MeshStandardMaterial({color:0x888888}));
                pole.rotation.z = Math.PI/2;
                pole.position.y = 9;
                mesh.add(pole);
                const clothGeo = new THREE.BoxGeometry(6,18,0.2);
                const clothMat = new THREE.MeshStandardMaterial({color:0xF5F5DC, side:THREE.DoubleSide});
                const leftC = new THREE.Mesh(clothGeo, clothMat);
                leftC.position.set(-3.5, 0, 0);
                leftC.userData.canTint = true;
                mesh.add(leftC);
                const rightC = new THREE.Mesh(clothGeo, clothMat.clone());
                rightC.position.set(3.5, 0, 0);
                rightC.userData.canTint = true;
                mesh.add(rightC);
            } else if (type === 'cattower') {
                baseSize = { w:5, h:15, d:5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(5,15,5), new THREE.MeshBasicMaterial({visible:false}));
                startY = 7.5;
                const mat = new THREE.MeshStandardMaterial({color:0xF5F5DC}); 
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,15), new THREE.MeshStandardMaterial({color:0x8B4513}));
                mesh.add(pole);
                const base = new THREE.Mesh(new THREE.BoxGeometry(5,1,5), mat);
                base.position.y = -7; base.userData.canTint = true; mesh.add(base);
                const mid = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), mat.clone());
                mid.position.y = 0; mid.userData.canTint = true; mesh.add(mid);
                const top = new THREE.Mesh(new THREE.BoxGeometry(4,0.5,4), mat.clone());
                top.position.y = 7; top.userData.canTint = true; mesh.add(top);
            } else if (type === 'doghouse') {
                baseSize = { w:6, h:6, d:7 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(6,6,7), new THREE.MeshBasicMaterial({visible:false}));
                startY = 3;
                const body = new THREE.Mesh(new THREE.BoxGeometry(6,4,7), new THREE.MeshStandardMaterial({color:0xFFE4C4}));
                body.position.y = -1;
                body.userData.canTint = true;
                mesh.add(body);
                const roofGeo = new THREE.CylinderGeometry(4.5, 4.5, 7, 3);
                const roofMat = new THREE.MeshStandardMaterial({color:0xA52A2A});
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,8), roofMat);
                r1.position.set(-1.5, 2.5, 0); r1.rotation.z = Math.PI/4;
                mesh.add(r1);
                const r2 = new THREE.Mesh(new THREE.BoxGeometry(5,0.5,8), roofMat);
                r2.position.set(1.5, 2.5, 0); r2.rotation.z = -Math.PI/4;
                mesh.add(r2);
                const hole = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), new THREE.MeshBasicMaterial({color:0x222}));
                hole.position.set(0, -1, 3.51);
                mesh.add(hole);
            } else if (type === 'plant') {
                baseSize = { w:4, h:8, d:4 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(4,8,4), new THREE.MeshBasicMaterial({visible:false}));
                startY = 4;
                const pot = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1, 3, 16), new THREE.MeshStandardMaterial({color:0x8B4513}));
                pot.position.y = -2.5;
                pot.userData.canTint = true;
                mesh.add(pot);
                const dirt = new THREE.Mesh(new THREE.CircleGeometry(1.4, 16), new THREE.MeshStandardMaterial({color:0x3d2817}));
                dirt.rotation.x = -Math.PI/2; dirt.position.y = -1.1;
                mesh.add(dirt);
                const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3), new THREE.MeshStandardMaterial({color:0x228B22}));
                stem.position.y = 0.5;
                mesh.add(stem);
                const leafGeo = new THREE.SphereGeometry(1.5, 8, 8);
                const leafMat = new THREE.MeshStandardMaterial({color:0x32CD32});
                const leaves = new THREE.Mesh(leafGeo, leafMat);
                leaves.position.y = 2.5; leaves.scale.y = 0.8;
                mesh.add(leaves);
            } else if (type === 'pantry') {
                baseSize = { w:8, h:18, d:4 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(8,18,4), new THREE.MeshBasicMaterial({visible:false}));
                startY = 9;
                const shelfMat = new THREE.MeshStandardMaterial({color:0x808080});
                const poleGeo = new THREE.BoxGeometry(0.2, 18, 0.2);
                const poleColor = new THREE.MeshStandardMaterial({color:0x333333});
                const p1 = new THREE.Mesh(poleGeo, poleColor); p1.position.set(-3.8, 0, -1.8); mesh.add(p1);
                const p2 = new THREE.Mesh(poleGeo, poleColor); p2.position.set(3.8, 0, -1.8); mesh.add(p2);
                const p3 = new THREE.Mesh(poleGeo, poleColor); p3.position.set(-3.8, 0, 1.8); mesh.add(p3);
                const p4 = new THREE.Mesh(poleGeo, poleColor); p4.position.set(3.8, 0, 1.8); mesh.add(p4);
                
                for(let i=0; i<5; i++) {
                    const shelf = new THREE.Mesh(new THREE.BoxGeometry(8, 0.3, 4), shelfMat.clone());
                    shelf.position.y = -8 + i * 4;
                    shelf.userData.canTint = true;
                    mesh.add(shelf);
                }
            } else { 
                baseSize = { w:5, h:5, d:5 };
                mesh = new THREE.Mesh(new THREE.BoxGeometry(5,5,5), new THREE.MeshStandardMaterial({color:0xccc}));
                mesh.userData.canTint = true;
                startY = 2.5;
            }

            if(mesh) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.position.y = startY;
                mesh.userData = { 
                    isFurniture: true, 
                    type: type, 
                    label: name,
                    baseW: baseSize.w, 
                    baseD: baseSize.d,
                    originalColor: material && material.color ? material.color.getHex() : 0xffffff
                };
                
                if (activeRoom) {
                    mesh.position.set(0, startY, 0); 
                    activeRoom.add(mesh);
                } else {
                    mesh.position.set(0, startY, 0);
                    scene.add(mesh);
                }

                furnitures.push(mesh);
                createLabel(mesh);
                
                selectObject(mesh);
            }
        }

        function createLabel(mesh) {
            const div = document.createElement('div');
            div.className = 'obj-label furniture-label';
            document.getElementById('labels-container').appendChild(div);
            mesh.userData.labelEl = div;
            
            div.addEventListener('pointerdown', (e) => {
                if(e.button !== 0) return;
                e.preventDefault(); 
                e.stopPropagation(); 
                startDragFromLabel(e, mesh);
            });

            updateLabel(mesh);
        }

        function startDragFromLabel(e, targetObj) {
            selectObject(targetObj);
            isDragging = true;
            controls.enabled = false; 
            updateMouse(e);
            raycaster.setFromCamera(mouse, camera);
            const planeIntersects = raycaster.intersectObject(dragPlane);
            if (planeIntersects.length > 0) {
                let targetPos = targetObj.userData.isFurniture ? targetObj.position : targetObj.parent.position;
                offset.copy(planeIntersects[0].point).sub(targetPos);
            }
        }

        function updateLabel(mesh) {
            if(!mesh.userData.labelEl) return;
            const w = Math.round(mesh.userData.baseW * mesh.scale.x * UNIT_TO_CM);
            const d = Math.round(mesh.userData.baseD * mesh.scale.z * UNIT_TO_CM);
            mesh.userData.labelEl.innerHTML = `<div style="color:#ffeb3b; font-weight:bold">${mesh.userData.label}</div><div>${w}x${d} cm</div>`;
            
            if(mesh === selectedObject && appMode === 'furniture') {
                document.getElementById('displayW').textContent = w + ' cm';
                document.getElementById('displayD').textContent = d + ' cm';
            }
        }

        function updateLabelsPos() {
            furnitures.forEach(f => {
                if(!f.userData.labelEl) return;
                const pos = new THREE.Vector3();
                f.getWorldPosition(pos);
                pos.y += 10; 
                pos.project(camera);
                updateElementPos(f.userData.labelEl, pos);
            });
            rooms.forEach(r => {
                if(!r.mesh.userData.labelEl) return;
                const pos = r.mesh.position.clone();
                pos.y = 1; 
                pos.project(camera);
                updateElementPos(r.mesh.userData.labelEl, pos);
            });
        }

        function updateElementPos(el, pos) {
            if(pos.z > 1) { el.style.display='none'; return; }
            const x = (pos.x * .5 + .5) * window.innerWidth;
            const y = (pos.y * -.5 + .5) * window.innerHeight;
            el.style.display='block';
            el.style.left = x+'px'; el.style.top = y+'px';
        }

        function clearAllFurniture() {
            furnitures.forEach(f => {
                f.parent.remove(f); 
                if(f.userData.labelEl) f.userData.labelEl.remove();
            });
            furnitures = [];
            if(selectedObject && selectedObject.userData.isFurniture) deselectObject();
        }

        function onMouseDown(event) {
            if (event.target.closest('#ui-layer') || event.target.closest('#ui-toggle-btn')) return;
            if (event.type !== 'touchstart' && event.button !== 0) return;
            
            updateMouse(event);
            raycaster.setFromCamera(mouse, camera);

            let candidates = [...furnitures];
            const floors = rooms.map(r => r.mesh.children.find(c => c.userData.isFloor)).filter(f=>f);
            candidates = candidates.concat(floors);

            const intersects = raycaster.intersectObjects(candidates, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                
                let selected = null;
                let curr = target;
                while (curr) {
                    if (curr.userData.isFurniture || curr.userData.isFloor) {
                        selected = curr;
                        break;
                    }
                    if (curr.parent === scene) break;
                    curr = curr.parent;
                }

                if (selected) {
                    let canSelect = false;
                    if (appMode === 'layout') {
                        if (selected.userData.isFloor) canSelect = true;
                    } else {
                        if (selected.userData.isFurniture || selected.userData.isFloor) canSelect = true;
                    }

                    if (canSelect) {
                        selectObject(selected);
                        
                        if(appMode === 'furniture' && selected.userData.isFloor) {
                            isDragging = false;
                        } else {
                            isDragging = true;
                            controls.enabled = false; 
                        }

                        const planeIntersects = raycaster.intersectObject(dragPlane);
                        if (planeIntersects.length > 0 && isDragging) {
                            const worldPos = new THREE.Vector3();
                            selected.getWorldPosition(worldPos);
                            offset.copy(planeIntersects[0].point).sub(worldPos);
                        }
                    }
                }
            } else {
                if(!isDragging) deselectObject();
            }
        }

        function onMouseMove(event) {
            updateMouse(event);
            
            raycaster.setFromCamera(mouse, camera);
            let hoverCandidates = [...furnitures, ...rooms.map(r => r.mesh.children.find(c => c.userData.isFloor)).filter(f=>f)];
            const intersects = raycaster.intersectObjects(hoverCandidates, true);
            document.body.style.cursor = intersects.length > 0 || isDragging ? 'pointer' : 'default';

            if (isDragging && selectedObject) {
                const planeIntersects = raycaster.intersectObject(dragPlane);
                if (planeIntersects.length > 0) {
                    const point = planeIntersects[0].point;
                    const targetWorldPos = point.sub(offset);

                    if (selectedObject.userData.isFloor) {
                        selectedObject.parent.position.set(targetWorldPos.x, 0, targetWorldPos.z);
                    } else if (selectedObject.userData.isFurniture) {
                        if (selectedObject.parent && selectedObject.parent.userData.isRoom) {
                            selectedObject.parent.worldToLocal(targetWorldPos);
                        }
                        
                        const room = selectedObject.parent;
                        if(room && room.userData.isRoom) {
                            const roomW = room.userData.w;
                            const roomH = room.userData.h;
                            
                            const angle = selectedObject.rotation.y;
                            const w = selectedObject.userData.baseW * selectedObject.scale.x;
                            const d = selectedObject.userData.baseD * selectedObject.scale.z;
                            
                            const boundW = Math.abs(Math.cos(angle)*w) + Math.abs(Math.sin(angle)*d);
                            const boundD = Math.abs(Math.sin(angle)*w) + Math.abs(Math.cos(angle)*d);
                            
                            const limitX = Math.max(0, (roomW - boundW) / 2);
                            const limitZ = Math.max(0, (roomH - boundD) / 2);
                            
                            targetWorldPos.x = Math.max(-limitX, Math.min(limitX, targetWorldPos.x));
                            targetWorldPos.z = Math.max(-limitZ, Math.min(limitZ, targetWorldPos.z));
                        }

                        selectedObject.position.set(targetWorldPos.x, selectedObject.position.y, targetWorldPos.z);
                    }
                }
            }
        }

        function onMouseUp() {
            if(isDragging) {
                isDragging = false;
                controls.enabled = true;
                if(!is2D) {
                    controls.enableRotate = true;
                } else {
                    controls.enableRotate = false;
                }
            }
        }

        function selectObject(obj) {
            if(selectedObject && selectedObject !== obj) deselectObject();
            selectedObject = obj;

            if (obj.material && obj.material.emissive) {
                obj.userData.currentEmissive = obj.material.emissive.getHex();
                obj.material.emissive.setHex(0x555555);
            }
            
            if (obj.userData.isFloor) {
                activeRoom = obj.parent; 
                obj.material.emissive.setHex(0x444444); 
                updateActiveRoomDisplay();
                
                if (appMode === 'layout') {
                    const p = document.getElementById('room-edit-panel');
                    p.style.display = 'block';
                    document.getElementById('editRoomName').value = obj.parent.userData.name;
                    document.getElementById('editRoomW').value = obj.parent.userData.w * UNIT_TO_CM;
                    document.getElementById('editRoomH').value = obj.parent.userData.h * UNIT_TO_CM;
                    document.getElementById('editRoomFloorColor').value = '#' + obj.material.color.getHexString();
                    const wall = obj.parent.children.find(c => c.userData.isWall);
                    if(wall) document.getElementById('editRoomWallColor').value = '#' + wall.material.color.getHexString();
                }
                document.getElementById('selection-panel').style.display = 'none';
            }
            else if (obj.userData.isFurniture) {
                controls.enableRotate = false; 

                const p = document.getElementById('selection-panel');
                p.style.display = 'block';
                document.getElementById('selected-name').textContent = obj.userData.label;
                document.getElementById('scaleX').value = obj.scale.x;
                document.getElementById('scaleZ').value = obj.scale.z;
                let deg = Math.round(obj.rotation.y * 180 / Math.PI);
                if(deg < 0) deg += 360;
                document.getElementById('rotation').value = deg % 360;
                document.getElementById('displayRotation').textContent = (deg % 360) + 'Â°';

                let targetColor = null;
                obj.traverse((child) => {
                    if (child.isMesh && child.userData.canTint) {
                        targetColor = child.material.color;
                    }
                });
                if (!targetColor && obj.material && obj.material.color && obj.visible) {
                    targetColor = obj.material.color;
                }
                
                if (targetColor) {
                    document.getElementById('editFurnitureColor').value = '#' + targetColor.getHexString();
                } else {
                     document.getElementById('editFurnitureColor').value = '#ffffff';
                }

                updateLabel(obj);
                updateActiveRoomDisplay();
                
                document.getElementById('room-edit-panel').style.display = 'none';
            }
        }

        function deselectObject() {
            if(!selectedObject) return;

            if(!is2D) controls.enableRotate = true;

            if (selectedObject.userData.isFloor) {
                selectedObject.material.emissive.setHex(0x000000);
                document.getElementById('room-edit-panel').style.display = 'none';
            }
            else if (selectedObject.userData.isFurniture) {
                 if(selectedObject.material && selectedObject.material.emissive) {
                     selectedObject.material.emissive.setHex(selectedObject.userData.currentEmissive || 0);
                 }
                 document.getElementById('selection-panel').style.display = 'none';
            }
            selectedObject = null;
            updateActiveRoomDisplay();
        }
        
        function updateActiveRoomDisplay() {
            const el = document.getElementById('active-room-indicator');
            let text = "";
            
            if (activeRoom) {
                text = `ì„ íƒëœ ë°©: <span style="color:#fff">${activeRoom.userData.name}</span> (ì—¬ê¸°ì— ê°€êµ¬ê°€ ì¶”ê°€ë©ë‹ˆë‹¤)`;
            } else {
                text = "ì„ íƒëœ ë°©: ì—†ìŒ (ë°© ì´ë¦„ì„ í´ë¦­í•˜ì„¸ìš”)";
            }

            if (selectedObject && selectedObject.userData.isFurniture) {
                text += ` / <span style="color:#ffeb3b">${selectedObject.userData.label}</span>`;
            }
            
            el.innerHTML = text;
        }

        function updateMouse(e) {
            let cx = e.clientX;
            let cy = e.clientY;
            if(e.changedTouches && e.changedTouches.length > 0) {
                cx = e.changedTouches[0].clientX;
                cy = e.changedTouches[0].clientY;
            }
            mouse.x = (cx / window.innerWidth) * 2 - 1;
            mouse.y = -(cy / window.innerHeight) * 2 + 1;
        }

        function resizeSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const sx = parseFloat(document.getElementById('scaleX').value);
                const sz = parseFloat(document.getElementById('scaleZ').value);
                selectedObject.scale.set(sx, 1, sz);
                updateLabel(selectedObject);
            }
        }

        function rotateSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const deg = parseFloat(document.getElementById('rotation').value);
                selectedObject.rotation.y = deg * Math.PI / 180;
                document.getElementById('displayRotation').textContent = deg + 'Â°';
            }
        }
        
        function deleteSelected() {
            if(selectedObject && selectedObject.userData.isFurniture) {
                const obj = selectedObject;
                obj.parent.remove(obj); 
                furnitures = furnitures.filter(f => f !== obj);
                if(obj.userData.labelEl) obj.userData.labelEl.remove();
                deselectObject();
            }
        }

        function toggleView() {
            is2D = !is2D;
            const btn = document.getElementById('toggleViewBtn');
            if(is2D) {
                btn.textContent = "3D ë·°ë¡œ ì „í™˜";
                controls.enableRotate = false;
                controls.reset();
                camera.position.set(0, 200, 0);
                camera.lookAt(0,0,0);
            } else {
                btn.textContent = "ë·° ì „í™˜ (3D â†” 2D)";
                controls.enableRotate = true;
                camera.position.set(60, 80, 80);
                camera.lookAt(0,0,0);
            }
        }

        function saveSceneAsImage() {
            // ë Œë”ë§ ì—…ë°ì´íŠ¸
            renderer.render(scene, camera);
            updateLabelsPos(); 
            
            // UI ìˆ¨ê¸°ê¸°
            const uiLayer = document.getElementById('ui-layer');
            const toggleBtn = document.getElementById('ui-toggle-btn');
            
            // ì›ë˜ display ì†ì„± ì €ì¥
            const originalUiDisplay = uiLayer.style.display;
            const originalBtnDisplay = toggleBtn.style.display;

            uiLayer.style.display = 'none';
            toggleBtn.style.display = 'none';

            // html2canvasë¡œ ì „ì²´ í™”ë©´ ìº¡ì²˜
            html2canvas(document.body, {
                backgroundColor: '#1a1a1a', 
                useCORS: true, 
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `home_design_${new Date().getTime()}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click();
                
                // UI ë³µêµ¬
                uiLayer.style.display = originalUiDisplay;
                toggleBtn.style.display = originalBtnDisplay;
            }).catch(err => {
                console.error("ìº¡ì²˜ ì‹¤íŒ¨:", err);
                alert("ë„ë©´ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                // ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ UI ë³µêµ¬
                uiLayer.style.display = originalUiDisplay;
                toggleBtn.style.display = originalBtnDisplay;
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            updateLabelsPos();
        }

        init();
    </script>
</body>
</html>
