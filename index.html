<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- ëª¨ë°”ì¼ ì¤Œ ë°©ì§€ ë° ë·°í¬íŠ¸ ì„¤ì • -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë°© ê°€êµ¬ ë°°ì¹˜ë„(ë‚¨ê¸°ë³µ)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #1a1a1a;
            color: white;
            /* ëª¨ë°”ì¼ì—ì„œ ë‹¹ê²¨ì„œ ìƒˆë¡œê³ ì¹¨ ë°©ì§€ */
            overscroll-behavior: none;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            /* ìº”ë²„ìŠ¤ í„°ì¹˜ ì¡°ì‘ ì‹œ ë¸Œë¼ìš°ì € ìŠ¤í¬ë¡¤ ë°©ì§€ */
            touch-action: none; 
        }
        /* ë¼ë²¨ ì»¨í…Œì´ë„ˆ */
        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }
        .obj-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            transform: translate(-50%, -100%);
            pointer-events: none;
            transition: opacity 0.2s;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 10;
        }
        
        /* UI í† ê¸€ ë²„íŠ¼ (ëª¨ë°”ì¼ìš©) */
        #ui-toggle-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 2000;
            background: rgba(0,0,0,0.8);
            color: white;
            border: 1px solid #555;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            display: none; /* ë°ìŠ¤í¬íƒ‘ì—ì„  ìˆ¨ê¹€ */
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
            width: 280px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            max-height: 90vh;
            overflow-y: auto;
            pointer-events: auto;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            z-index: 1000;
        }
        
        /* ëª¨ë°”ì¼ ë°˜ì‘í˜• ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) {
            #ui-toggle-btn {
                display: block;
            }
            #ui-layer {
                top: 70px; /* ë²„íŠ¼ ì•„ë˜ë¡œ ì´ë™ */
                left: 50%;
                transform: translateX(-50%); /* ì¤‘ì•™ ì •ë ¬ */
                width: 85%; /* í™”ë©´ ê½‰ ì°¨ê²Œ */
                max-height: 70vh;
            }
            #ui-layer.collapsed {
                transform: translateX(-50%) translateY(-150%); /* ìœ„ë¡œ ìˆ¨ê¸°ê¸° */
                opacity: 0;
                pointer-events: none;
            }
            .btn {
                padding: 14px; /* í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
                font-size: 14px;
            }
            input[type="range"] {
                height: 20px; /* ìŠ¬ë¼ì´ë” í„°ì¹˜ ì˜ì—­ í™•ëŒ€ */
            }
        }

        #ui-layer::-webkit-scrollbar { width: 6px; }
        #ui-layer::-webkit-scrollbar-thumb { background-color: #555; border-radius: 3px; }
        
        h1 {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #eee;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .control-group {
            margin-bottom: 20px;
            border-bottom: 1px solid #444;
            padding-bottom: 15px;
        }
        .control-group:last-child { border-bottom: none; }
        .control-label {
            font-size: 12px; 
            color:#aaa; 
            margin-bottom: 8px; 
            display: block;
            font-weight: bold;
        }
        .size-display {
            float: right;
            color: #ffd700;
            font-weight: normal;
        }
        .btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: all 0.2s;
            text-align: center;
            color: white;
        }
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .btn-view { background-color: #3b82f6; }
        .btn-save { background-color: #10b981; }
        .btn-danger { background-color: #d32f2f; }
        
        .input-row { display: flex; gap: 5px; margin-bottom: 5px; }
        input[type="number"], input[type="text"], select {
            width: 100%; padding: 10px; background: #333; border: 1px solid #555; color: white; border-radius: 4px; box-sizing: border-box; font-size: 14px;
        }
        input[type="range"] { width: 100%; margin: 10px 0; cursor: pointer; }
        
        #selection-panel {
            display: none;
            background: rgba(60, 60, 60, 0.4);
            border: 1px solid #555;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        .instruction {
            margin-top: 10px; font-size: 11px; color: #888; line-height: 1.4;
        }
    </style>
    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="labels-container"></div>
    
    <!-- ëª¨ë°”ì¼ìš© ë©”ë‰´ í† ê¸€ ë²„íŠ¼ -->
    <button id="ui-toggle-btn" onclick="toggleUI()">â˜° ë©”ë‰´</button>

    <div id="ui-layer">
        <h1>ğŸ› ï¸ ë°© ê¾¸ë¯¸ê¸° ì„¤ì • 
            <!-- ë°ìŠ¤í¬íƒ‘ìš© ë‹«ê¸° ë²„íŠ¼ (ëª¨ë°”ì¼ì€ ì™¸ë¶€ ë²„íŠ¼ ì‚¬ìš©) -->
            <span style="font-size:12px; cursor:pointer; display:none;" onclick="toggleUI()">âœ•</span>
        </h1>
        
        <!-- ë·° ë° ì €ì¥ -->
        <div class="control-group">
            <button class="btn btn-view" id="toggleViewBtn" onclick="toggleView()">ë·° ì „í™˜ (3D â†” 2D)</button>
            <button class="btn btn-save" onclick="saveSceneAsImage()">ğŸ“· ë„ë©´ ì´ë¯¸ì§€ ì €ì¥ (.png)</button>
        </div>

        <!-- ë°© í¬ê¸° ì¡°ì ˆ -->
        <div class="control-group">
            <span class="control-label">ë°© í¬ê¸° ì„¤ì • (ë‹¨ìœ„: cm)</span>
            <div class="input-row">
                <input type="number" id="roomW" value="400" min="200" max="1500" placeholder="ê°€ë¡œ (cm)">
                <input type="number" id="roomH" value="400" min="200" max="1500" placeholder="ì„¸ë¡œ (cm)">
                <button class="btn btn-view" style="width: 60px; margin:0;" onclick="updateRoomSize()">ì ìš©</button>
            </div>
        </div>

        <!-- ê°€êµ¬ ì¶”ê°€ (ì‚¬ìš©ì ì…ë ¥ ë°©ì‹) -->
        <div class="control-group">
            <span class="control-label">ì‹ ê·œ ê°€êµ¬ ì¶”ê°€</span>
            <input type="text" id="newFurnitureName" placeholder="ê°€êµ¬ ì´ë¦„ ì…ë ¥ (ì˜ˆ: ë‚´ ì±…ìƒ)" style="margin-bottom: 8px;">
            <div class="input-row">
                <select id="newFurnitureType">
                    <option value="bed">ì¹¨ëŒ€ (ë”ë¸”)</option>
                    <option value="desk">ì±…ìƒ</option>
                    <option value="wardrobe">ì˜·ì¥</option>
                    <option value="lamp">ì¡°ëª… (ìŠ¤íƒ ë“œ)</option>
                    <option value="box">ê¸°ë³¸ ë°•ìŠ¤</option>
                </select>
                <button class="btn btn-view" style="width: 60px; margin:0;" onclick="handleAddCustom()">ì¶”ê°€</button>
            </div>
            <button class="btn btn-danger" style="margin-top: 10px;" onclick="clearRoom()">ëª¨ë‘ ì§€ìš°ê¸°</button>
        </div>

        <!-- ì„ íƒëœ ê°€êµ¬ ì˜µì…˜ -->
        <div id="selection-panel">
            <span class="control-label" style="color: #4fc3f7;">ì„ íƒë¨: <span id="selected-name">-</span></span>
            
            <span class="control-label" style="margin-top:5px;">íšŒì „ (Rotation 360Â°)</span>
            <input type="range" id="rotation" min="0" max="360" step="5" value="0" oninput="rotateSelected()">

            <span class="control-label" style="margin-top:5px;">
                ê°€ë¡œ ê¸¸ì´ (W) <span id="displayW" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleX" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">
            
            <span class="control-label">
                ê¹Šì´/ì„¸ë¡œ (D) <span id="displayD" class="size-display">0 cm</span>
            </span>
            <input type="range" id="scaleZ" min="0.5" max="2.5" step="0.05" value="1.0" oninput="resizeSelected()">

            <button class="btn btn-danger" onclick="deleteSelected()">ì„ íƒ ê°€êµ¬ ì‚­ì œ ğŸ—‘ï¸</button>
        </div>

        <div class="instruction">
            <strong>Tip:</strong><br>
            â€¢ ëª¨ë°”ì¼: ë©”ë‰´ ë²„íŠ¼ìœ¼ë¡œ íŒ¨ë„ì„ ì—¬ë‹«ìœ¼ì„¸ìš”.<br>
            â€¢ í„°ì¹˜ ë“œë˜ê·¸ë¡œ ê°€êµ¬ë¥¼ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let scene, camera, renderer;
        let plane, gridHelper; 
        let wallGroup = new THREE.Group();
        let raycaster, mouse;
        let furnitureObjects = [];
        let isDragging = false;
        let selectedObject = null;
        let offset = new THREE.Vector3();
        let is2D = false; 

        // ë‚´ë¶€ ë‹¨ìœ„ ì„¤ì • (1 unit = 10cm)
        let currentRoomW = 40; 
        let currentRoomH = 40; 
        const UNIT_TO_CM = 10; 
        const WALL_HEIGHT = 15;

        // UI í† ê¸€ í•¨ìˆ˜
        function toggleUI() {
            const ui = document.getElementById('ui-layer');
            const btn = document.getElementById('ui-toggle-btn');
            
            ui.classList.toggle('collapsed');
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½ (ì„ íƒì‚¬í•­)
            if(ui.classList.contains('collapsed')) {
                btn.innerHTML = 'â˜° ë©”ë‰´';
            } else {
                btn.innerHTML = 'âœ• ë‹«ê¸°';
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            scene.fog = new THREE.Fog(0xf0f0f0, 50, 250);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // í”½ì…€ ë¹„ìœ¨ ì„¤ì • (ê³ í•´ìƒë„ ë””ìŠ¤í”Œë ˆì´ ëŒ€ì‘)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.6);
            mainLight.position.set(50, 100, 50);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            scene.add(wallGroup);
            createRoom(currentRoomW, currentRoomH);

            addFurniture('bed', 'ë‚´ ì¹¨ëŒ€');

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            
            // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ (Passive: falseë¡œ ì„¤ì •í•˜ì—¬ preventDefault í—ˆìš©)
            canvas.addEventListener('touchstart', onTouchStart, {passive: false});
            canvas.addEventListener('touchmove', onTouchMove, {passive: false});
            canvas.addEventListener('touchend', onMouseUp, false);

            animate();
        }

        function createRoom(width, height) {
            if(plane) scene.remove(plane);
            if(gridHelper) scene.remove(gridHelper);
            while(wallGroup.children.length > 0){ wallGroup.remove(wallGroup.children[0]); }

            const planeGeometry = new THREE.PlaneGeometry(width, height);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, side: THREE.DoubleSide });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            plane.name = "floor";
            scene.add(plane);

            gridHelper = new THREE.GridHelper(Math.max(width, height), Math.max(width, height)/5, 0xcccccc, 0xe5e5e5);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const thickness = 1;
            
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(width + thickness*2, WALL_HEIGHT, thickness), wallMaterial);
            backWall.position.set(0, WALL_HEIGHT/2, -height/2 - thickness/2);
            backWall.receiveShadow = true;
            wallGroup.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(thickness, WALL_HEIGHT, height), wallMaterial);
            leftWall.position.set(-width/2 - thickness/2, WALL_HEIGHT/2, 0);
            leftWall.receiveShadow = true;
            wallGroup.add(leftWall);
        }

        function updateRoomSize() {
            const w_cm = parseInt(document.getElementById('roomW').value);
            const h_cm = parseInt(document.getElementById('roomH').value);
            
            if(w_cm && h_cm) {
                currentRoomW = w_cm / UNIT_TO_CM;
                currentRoomH = h_cm / UNIT_TO_CM;
                createRoom(currentRoomW, currentRoomH);
            }
        }

        function handleAddCustom() {
            const nameInput = document.getElementById('newFurnitureName');
            const typeSelect = document.getElementById('newFurnitureType');
            
            let name = nameInput.value.trim();
            const type = typeSelect.value;
            
            if (!name) {
                const typeText = typeSelect.options[typeSelect.selectedIndex].text.split(' ')[0];
                name = `ë‚˜ì˜ ${typeText}`;
            }

            addFurniture(type, name);
            nameInput.value = '';
            
            // ëª¨ë°”ì¼ì—ì„œëŠ” ì¶”ê°€ í›„ íŒ¨ë„ì´ ê°€ë¦¬ì§€ ì•Šë„ë¡ ë‹«ì•„ì£¼ëŠ” ê²ƒë„ ê³ ë ¤í•´ë³¼ ë§Œí•¨
            // toggleUI(); 
        }

        function addFurniture(type, customName) {
            let geometry, material, mesh;
            let startY = 0;
            let baseSize = { w: 0, h: 0, d: 0 }; 

            if (type === 'bed') {
                baseSize = { w: 14, h: 4, d: 20 }; 
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
                
                const mattress = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w - 0.5, 2, baseSize.d - 0.5), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                mattress.position.y = baseSize.h/2 + 1;
                mesh.add(mattress);
                
                const pillow = new THREE.Mesh(new THREE.BoxGeometry(baseSize.w - 2, 1, 4), new THREE.MeshStandardMaterial({ color: 0xeeeeee }));
                pillow.position.set(0, baseSize.h/2 + 2, -baseSize.d/2 + 3);
                mesh.add(pillow);

            } else if (type === 'desk') {
                baseSize = { w: 12, h: 7, d: 6 }; 
                geometry = new THREE.BoxGeometry(baseSize.w, 0.5, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xA0522D });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h;

                const legGeo = new THREE.BoxGeometry(1, baseSize.h, 1);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                const positions = [
                    {x: -baseSize.w/2 + 1, z: -baseSize.d/2 + 1}, {x: baseSize.w/2 - 1, z: -baseSize.d/2 + 1},
                    {x: -baseSize.w/2 + 1, z: baseSize.d/2 - 1}, {x: baseSize.w/2 - 1, z: baseSize.d/2 - 1}
                ];
                positions.forEach(pos => {
                    const leg = new THREE.Mesh(legGeo, legMat);
                    leg.position.set(pos.x, -baseSize.h/2, pos.z);
                    mesh.add(leg);
                });

            } else if (type === 'wardrobe') {
                baseSize = { w: 8, h: 18, d: 6 }; 
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0x555555 });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;

            } else if (type === 'lamp') {
                baseSize = { w: 3, h: 10, d: 3 }; 
                geometry = new THREE.CylinderGeometry(0.3, 0.5, 8, 16);
                material = new THREE.MeshStandardMaterial({ color: 0x222222 });
                mesh = new THREE.Mesh(geometry, material);
                startY = 4;

                const shade = new THREE.Mesh(
                    new THREE.ConeGeometry(2, 2, 32, 1, true),
                    new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.5, side: THREE.DoubleSide })
                );
                shade.position.y = 3;
                mesh.add(shade);

                const pointLight = new THREE.PointLight(0xFFAA00, 1, 30);
                pointLight.position.set(0, 2, 0);
                pointLight.castShadow = true;
                mesh.add(pointLight);

                const base = new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                base.position.y = -4;
                mesh.add(base);

            } else if (type === 'box') {
                baseSize = { w: 5, h: 5, d: 5 }; 
                geometry = new THREE.BoxGeometry(baseSize.w, baseSize.h, baseSize.d);
                material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
                mesh = new THREE.Mesh(geometry, material);
                startY = baseSize.h / 2;
            }

            if (mesh) {
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.position.y = startY;
                mesh.position.x = 0;
                mesh.position.z = 0;

                mesh.userData = { 
                    isFurniture: true, 
                    type: type, 
                    label: customName,
                    baseW: baseSize.w,
                    baseD: baseSize.d,
                    originalColor: material.color ? material.color.getHex() : 0xffffff
                };

                scene.add(mesh);
                furnitureObjects.push(mesh);
                createLabelElement(mesh);
                selectObject(mesh);
            }
        }

        function createLabelElement(mesh) {
            const div = document.createElement('div');
            div.className = 'obj-label';
            document.getElementById('labels-container').appendChild(div);
            mesh.userData.labelElement = div;
            updateLabelText(mesh);
        }

        function updateLabelText(mesh) {
            if(!mesh.userData.labelElement) return;
            const widthCm = Math.round(mesh.userData.baseW * mesh.scale.x * UNIT_TO_CM);
            const depthCm = Math.round(mesh.userData.baseD * mesh.scale.z * UNIT_TO_CM);
            
            mesh.userData.labelElement.innerHTML = `
                <div style="font-weight:bold; color:#ffeb3b;">${mesh.userData.label}</div>
                <div style="font-size:10px; color:#ddd;">${widthCm} x ${depthCm} cm</div>
            `;
            
            if (mesh === selectedObject) {
                document.getElementById('displayW').textContent = `${widthCm} cm`;
                document.getElementById('displayD').textContent = `${depthCm} cm`;
            }
        }

        function removeLabelElement(mesh) {
            if (mesh.userData.labelElement) {
                mesh.userData.labelElement.remove();
                mesh.userData.labelElement = null;
            }
        }

        function updateLabelsPosition() {
            furnitureObjects.forEach(mesh => {
                const label = mesh.userData.labelElement;
                if (!label) return;

                const pos = mesh.position.clone();
                pos.y += 5; 
                pos.project(camera);

                if (pos.z > 1) { 
                    label.style.display = 'none';
                    return;
                }

                const x = (pos.x * .5 + .5) * window.innerWidth;
                const y = (pos.y * -.5 + .5) * window.innerHeight;

                label.style.display = 'block';
                label.style.transform = `translate(-50%, -100%)`;
                label.style.left = `${x}px`;
                label.style.top = `${y}px`;
            });
        }

        function clearRoom() {
            furnitureObjects.forEach(obj => { scene.remove(obj); removeLabelElement(obj); });
            furnitureObjects = [];
            deselectObject();
        }

        function deleteSelected() {
            if(selectedObject) {
                scene.remove(selectedObject);
                removeLabelElement(selectedObject);
                furnitureObjects = furnitureObjects.filter(obj => obj !== selectedObject);
                deselectObject();
            }
        }

        function saveSceneAsImage() {
            renderer.render(scene, camera);
            try {
                const imgData = renderer.domElement.toDataURL("image/png");
                const link = document.createElement('a');
                link.download = `room_design_${new Date().getTime()}.png`;
                link.href = imgData;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error("ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨", e);
                alert("ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨.");
            }
        }

        function toggleView() {
            is2D = !is2D;
            updateCameraPosition();
            document.getElementById('toggleViewBtn').textContent = is2D ? "3D ë·°ë¡œ ì „í™˜" : "í‰ë©´ë„(2D)ë¡œ ì „í™˜";
        }

        function updateCameraPosition() {
            if (is2D) {
                camera.position.set(0, Math.max(currentRoomW, currentRoomH) * 1.5, 0);
                camera.lookAt(0, 0, 0);
            } else {
                camera.position.set(currentRoomW * 0.8, 40, currentRoomH * 0.8);
                camera.lookAt(0, 0, 0);
            }
            camera.updateProjectionMatrix();
        }

        function selectObject(obj) {
            if(selectedObject && selectedObject !== obj) deselectObject();
            selectedObject = obj;
            
            if(selectedObject.material && selectedObject.material.emissive) {
                if(!selectedObject.userData.currentEmissive) {
                     selectedObject.userData.currentEmissive = selectedObject.material.emissive.getHex();
                }
                selectedObject.material.emissive.setHex(0x666666);
            }

            const panel = document.getElementById('selection-panel');
            panel.style.display = 'block';
            document.getElementById('selected-name').textContent = obj.userData.label;
            
            document.getElementById('scaleX').value = obj.scale.x;
            document.getElementById('scaleZ').value = obj.scale.z;
            
            let degrees = Math.round(obj.rotation.y * 180 / Math.PI);
            if(degrees < 0) degrees += 360; 
            document.getElementById('rotation').value = degrees % 360;

            updateLabelText(obj);
        }

        function deselectObject() {
            if(selectedObject) {
                if(selectedObject.material && selectedObject.material.emissive) {
                     const orig = selectedObject.userData.currentEmissive || 0x000000;
                     selectedObject.material.emissive.setHex(orig);
                }
            }
            selectedObject = null;
            document.getElementById('selection-panel').style.display = 'none';
        }

        function resizeSelected() {
            if(!selectedObject) return;
            const sx = parseFloat(document.getElementById('scaleX').value);
            const sz = parseFloat(document.getElementById('scaleZ').value);
            selectedObject.scale.set(sx, 1, sz);
            updateLabelText(selectedObject);
        }

        function rotateSelected() {
            if(!selectedObject) return;
            const degrees = parseInt(document.getElementById('rotation').value);
            selectedObject.rotation.y = degrees * Math.PI / 180;
        }

        function getIntersects(event, element) {
            raycaster.setFromCamera(mouse, camera);
            return raycaster.intersectObjects(furnitureObjects, false);
        }

        // í„°ì¹˜ ì‹œì‘ ì‹œ ìŠ¤í¬ë¡¤ ë°©ì§€
        function onTouchStart(event) { 
            event.preventDefault(); 
            onMouseDown(event); 
        }
        
        // í„°ì¹˜ ì´ë™ ì‹œ ìŠ¤í¬ë¡¤ ë°©ì§€ ë° ì¢Œí‘œ ì—…ë°ì´íŠ¸
        function onTouchMove(event) { 
            event.preventDefault(); 
            onMouseMove(event); 
        }

        function updateMouseCoords(event, element) {
            const rect = element.getBoundingClientRect();
            let clientX, clientY;
            if (event.changedTouches) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
        }

        function onMouseDown(event) {
            updateMouseCoords(event, renderer.domElement);
            const intersects = getIntersects(event, renderer.domElement);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while(target.parent && target.parent.type !== 'Scene') target = target.parent;

                if (furnitureObjects.includes(target)) {
                    isDragging = true;
                    selectObject(target);
                    const planeIntersects = raycaster.intersectObject(plane);
                    if (planeIntersects.length > 0) {
                        offset.copy(planeIntersects[0].point).sub(selectedObject.position);
                    }
                }
            } else {
                raycaster.setFromCamera(mouse, camera);
                const planeTest = raycaster.intersectObject(plane);
                if(planeTest.length > 0) deselectObject();
            }
        }

        function onMouseMove(event) {
            // ë§ˆìš°ìŠ¤ ì´ë™ì€ preventDefaultë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šì•„ë„ ë˜ì§€ë§Œ, 
            // í„°ì¹˜ ì´ë²¤íŠ¸ë¥¼ í†µí•´ í˜¸ì¶œë  ë•ŒëŠ” ìƒìœ„ í•¸ë“¤ëŸ¬ì—ì„œ ì²˜ë¦¬ë¨
            updateMouseCoords(event, renderer.domElement);

            if(isDragging) {
                document.body.style.cursor = 'move';
            } else {
                const intersects = getIntersects(event, renderer.domElement);
                document.body.style.cursor = intersects.length > 0 ? 'pointer' : 'default';
            }

            if (isDragging && selectedObject) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(plane);
                
                if (intersects.length > 0) {
                    const newPos = intersects[0].point.sub(offset);
                    
                    const rot = selectedObject.rotation.y;
                    const baseW = selectedObject.userData.baseW;
                    const baseD = selectedObject.userData.baseD;
                    const scaleX = selectedObject.scale.x;
                    const scaleZ = selectedObject.scale.z;

                    const currentBoxW = Math.abs(Math.cos(rot) * baseW * scaleX) + Math.abs(Math.sin(rot) * baseD * scaleZ);
                    const currentBoxD = Math.abs(Math.sin(rot) * baseW * scaleX) + Math.abs(Math.cos(rot) * baseD * scaleZ);

                    const limitX = (currentRoomW / 2) - (currentBoxW / 2);
                    const limitZ = (currentRoomH / 2) - (currentBoxD / 2);
                    
                    const clampedX = limitX > 0 ? Math.max(-limitX, Math.min(limitX, newPos.x)) : 0;
                    const clampedZ = limitZ > 0 ? Math.max(-limitZ, Math.min(limitZ, newPos.z)) : 0;

                    selectedObject.position.x = clampedX;
                    selectedObject.position.z = clampedZ;
                }
            }
        }

        function onMouseUp(event) { isDragging = false; }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateLabelsPosition();
        }

        init();
    </script>
</body>
</html>
